                                  
                                  
┌────────────────────────────────┐
│ 202 Non-blocking Code Findings │
└────────────────────────────────┘
                                     
    src/ajax/lookup-pen-test-tool.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          157┆ echo $lPenTestToolsJSON;
    
    
          Taint comes from:
    
          116┆ $lPostedToolID = $_POST["ToolID"];
    
    
          Taint flows through these intermediate variables:
    
          116┆ $lPostedToolID = $_POST["ToolID"];
    
          138┆ $lPenTestToolsJSON =
    
    
                This is how taint reaches the sink:
    
          157┆ echo $lPenTestToolsJSON;
    
                                    
    src/arbitrary-file-inclusion.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           60┆ <td class="label">Current Page: <?php echo $lPage; ?></td>
    
    
          Taint comes from:
    
           39┆ $lPage = $Encoder->encodeForHTML($_GET['page']);
    
    
          Taint flows through these intermediate variables:
    
           39┆ $lPage = $Encoder->encodeForHTML($_GET['page']);
    
    
                This is how taint reaches the sink:
    
           60┆ <td class="label">Current Page: <?php echo $lPage; ?></td>
    
                        
    src/browser-info.php
   ❯❯❱ php.lang.security.tainted-user-input-in-php-script.tainted-user-input-in-php-script
          Untrusted input could be used to tamper with a web page rendering, which can lead to a Cross-site  
          scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted input executes malicious   
          JavaScript code, leading to issues such as account compromise and sensitive information leakage. To
          prevent this vulnerability, validate the user input, perform contextual output encoding or sanitize
          the input. In PHP you can encode or sanitize user input with `htmlspecialchars` or use automatic   
          context-aware escaping with a template engine such as Latte.                                       
          Details: https://sg.run/PKkY                                                                       
                                                                                                             
           86┆ echo '<tr><th class="report-label">Cookie '.$Encoder->encodeForHTML($key).'</th><td
               class="report-data">'.$Encoder->encodeForHTML($value).'</pre></td></tr>';          
    
    
          Taint comes from:
    
           85┆ foreach ($_COOKIE as $key => $value){
    
    
          Taint flows through these intermediate variables:
    
           85┆ foreach ($_COOKIE as $key => $value){
    
           85┆ foreach ($_COOKIE as $key => $value){
    
    
                This is how taint reaches the sink:
    
           86┆ echo '<tr><th class="report-label">Cookie '.$Encoder->encodeForHTML($key).'</th><td
               class="report-data">'.$Encoder->encodeForHTML($value).'</pre></td></tr>';          
    
    
            ⋮┆----------------------------------------
           90┆ echo '<tr><th class="report-label" class="non-wrapping-label">Cookie '.$key.'</th><td
               class="report-data">'.$value.'</pre></td></tr>';                                     
    
    
          Taint comes from:
    
           89┆ foreach ($_COOKIE as $key => $value){
    
    
          Taint flows through these intermediate variables:
    
           89┆ foreach ($_COOKIE as $key => $value){
    
           89┆ foreach ($_COOKIE as $key => $value){
    
    
                This is how taint reaches the sink:
    
           90┆ echo '<tr><th class="report-label" class="non-wrapping-label">Cookie '.$key.'</th><td
               class="report-data">'.$value.'</pre></td></tr>';                                     
    
                                     
    src/classes/RemoteFileHandler.php
   ❯❯❱ php.lang.security.curl-ssl-verifypeer-off.curl-ssl-verifypeer-off
          SSL verification is disabled but should not be (currently CURLOPT_SSL_VERIFYPEER= false)
          Details: https://sg.run/PJqv                                                            
                                                                                                  
           62┆ curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
                                  
    src/conference-room-lookup.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          161┆ echo $key['cn'][0];
    
    
          Taint comes from:
    
           55┆ $lProtectAgainstMethodTampering?$lRoomCommonName =   
               $_POST["default_room_common_name"]:$lRoomCommonName =
               $_REQUEST["default_room_common_name"];               
    
    
          Taint flows through these intermediate variables:
    
           55┆ $lProtectAgainstMethodTampering?$lRoomCommonName =   
               $_POST["default_room_common_name"]:$lRoomCommonName =
               $_REQUEST["default_room_common_name"];               
    
           63┆ $lRoomCommonNameText = $lRoomCommonName;
    
          152┆ $filter="(|(cn=2F204)(cn=".$lRoomCommonNameText."))";
    
          153┆ $sr=ldap_search($ldapconn, LDAP_BASE_DN, $filter);
    
          155┆ $entries = ldap_get_entries($ldapconn, $sr);
    
          158┆ foreach ($entries as $key) {
    
          158┆ foreach ($entries as $key) {
    
    
                This is how taint reaches the sink:
    
          161┆ echo $key['cn'][0];
    
    
            ⋮┆----------------------------------------
          170┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lRoomCommonNameText);
    
    
          Taint comes from:
    
           55┆ $lProtectAgainstMethodTampering?$lRoomCommonName =   
               $_POST["default_room_common_name"]:$lRoomCommonName =
               $_REQUEST["default_room_common_name"];               
    
    
          Taint flows through these intermediate variables:
    
           55┆ $lProtectAgainstMethodTampering?$lRoomCommonName =   
               $_POST["default_room_common_name"]:$lRoomCommonName =
               $_REQUEST["default_room_common_name"];               
    
           63┆ $lRoomCommonNameText = $lRoomCommonName;
    
    
                This is how taint reaches the sink:
    
          170┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lRoomCommonNameText);
    
                                   
    src/content-security-policy.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          113┆ echo '<div class="report-header">Results for '.$lMessageText.'</div>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
           51┆ $lMessageText = $lMessage;                 //allow XSS by not encoding output
    
    
                This is how taint reaches the sink:
    
          113┆ echo '<div class="report-header">Results for '.$lMessageText.'</div>';
    
    
            ⋮┆----------------------------------------
          116┆ echo '<pre class="output">'.$lMessageText.'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
           51┆ $lMessageText = $lMessage;                 //allow XSS by not encoding output
    
    
                This is how taint reaches the sink:
    
          116┆ echo '<pre class="output">'.$lMessageText.'</pre>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.injection.tainted-exec.tainted-exec
          User input is passed to a function that executes a shell command. This can lead to remote code
          execution.                                                                                    
          Details: https://sg.run/kxEEz                                                                 
                                                                                                        
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❯❱ php.lang.security.tainted-command-injection.tainted-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input that is used respectively as system commands or   
          command arguments.                                                                                  
          Details: https://sg.run/Bpj2                                                                        
                                                                                                              
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-exec.tainted-exec
          Executing non-constant commands. This can lead to command injection. You should use
          `escapeshellarg()` when using command.                                             
          Details: https://sg.run/JAkP                                                       
                                                                                             
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.laravel.security.laravel-command-injection.laravel-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input when used respectively as system commands or      
          command arguments.                                                                                  
          Details: https://sg.run/JPYR                                                                        
                                                                                                              
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          119┆ echo '<pre class="output">'.shell_exec("echo -n " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          124┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lMessage);
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          124┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lMessage);
    
                            
    src/database-offline.php
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
           40┆ $lDatabasePingResult = shell_exec("ping -c 1 $lDatabaseHost");
            ⋮┆----------------------------------------
           46┆ $lDatabaseTracerouteResult = shell_exec("traceroute --max-hops=2 --wait=2 $lDatabaseHost
               2>&1");                                                                                 
            ⋮┆----------------------------------------
           52┆ $lTracerouteTCPResult = shell_exec("traceroute --max-hops=2 --wait=2 --tcp -p
               $lDatabasePort $lDatabaseHost 2>&1");                                        
            ⋮┆----------------------------------------
           86┆ $lLDAPPingResult = shell_exec("ping -c 1 $lLDAPHost");
            ⋮┆----------------------------------------
           92┆ $lLDAPTracerouteResult = shell_exec("traceroute --max-hops=2 --wait=2 $lLDAPHost 2>&1");
            ⋮┆----------------------------------------
           98┆ $lTracerouteTCPResult = shell_exec("traceroute --max-hops=2 --wait=2 --tcp -p $lLDAPPort
               $lLDAPHost 2>&1");                                                                      
                      
    src/dns-lookup.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          151┆ echo '<div class="report-header">Results for '.$lTargetHostText.'</div>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
           59┆ $lTargetHostText = $lTargetHost;           //allow XSS by not encoding output
    
    
                This is how taint reaches the sink:
    
          151┆ echo '<div class="report-header">Results for '.$lTargetHostText.'</div>';
    
    
            ⋮┆----------------------------------------
          158┆ echo $lRecord.': '.$lValue.'<br />';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
          153┆ $lResults = dns_get_record($lTargetHost, DNS_A);
    
          155┆ foreach ($lResults as $lItem => $lArray) {
    
          155┆ foreach ($lResults as $lItem => $lArray) {
    
          156┆ foreach ($lArray as $lRecord => $lValue) {
    
          156┆ foreach ($lArray as $lRecord => $lValue) {
    
    
                This is how taint reaches the sink:
    
          158┆ echo $lRecord.': '.$lValue.'<br />';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
                This is how taint reaches the sink:
    
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.injection.tainted-exec.tainted-exec
          User input is passed to a function that executes a shell command. This can lead to remote code
          execution.                                                                                    
          Details: https://sg.run/kxEEz                                                                 
                                                                                                        
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
                This is how taint reaches the sink:
    
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❯❱ php.lang.security.tainted-command-injection.tainted-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input that is used respectively as system commands or   
          command arguments.                                                                                  
          Details: https://sg.run/Bpj2                                                                        
                                                                                                              
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
                This is how taint reaches the sink:
    
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-exec.tainted-exec
          Executing non-constant commands. This can lead to command injection. You should use
          `escapeshellarg()` when using command.                                             
          Details: https://sg.run/JAkP                                                       
                                                                                             
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
                This is how taint reaches the sink:
    
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.laravel.security.laravel-command-injection.laravel-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input when used respectively as system commands or      
          command arguments.                                                                                  
          Details: https://sg.run/JPYR                                                                        
                                                                                                              
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
                This is how taint reaches the sink:
    
          165┆ echo '<pre class="output">'.shell_exec("nslookup " . $lTargetHost).'</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          173┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lTargetHost);
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lTargetHost = $_POST["target_host"]:$lTargetHost =
               $_REQUEST["target_host"];                                                          
    
    
                This is how taint reaches the sink:
    
          173┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lTargetHost);
    
                           
    src/document-viewer.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          148┆ echo $lDocumentToBeFramedMessage;
    
    
          Taint comes from:
    
           79┆ $lDocumentToBeFramed = $_GET["PathToDocument"];
    
    
          Taint flows through these intermediate variables:
    
           79┆ $lDocumentToBeFramed = $_GET["PathToDocument"];
    
           92┆ $lDocumentToBeFramedMessage = "Currently viewing document
               &quot;{$lDocumentToBeFramed}&quot;";                     
    
           92┆ $lDocumentToBeFramedMessage = "Currently viewing document
               &quot;{$lDocumentToBeFramed}&quot;";                     
    
    
                This is how taint reaches the sink:
    
          148┆ echo $lDocumentToBeFramedMessage;
    
    
            ⋮┆----------------------------------------
          150┆ echo $Encoder->encodeForHTML($lDocumentToBeFramedMessage);
    
    
          Taint comes from:
    
           79┆ $lDocumentToBeFramed = $_GET["PathToDocument"];
    
    
          Taint flows through these intermediate variables:
    
           79┆ $lDocumentToBeFramed = $_GET["PathToDocument"];
    
           92┆ $lDocumentToBeFramedMessage = "Currently viewing document
               &quot;{$lDocumentToBeFramed}&quot;";                     
    
           92┆ $lDocumentToBeFramedMessage = "Currently viewing document
               &quot;{$lDocumentToBeFramed}&quot;";                     
    
    
                This is how taint reaches the sink:
    
          150┆ echo $Encoder->encodeForHTML($lDocumentToBeFramedMessage);
    
    
            ⋮┆----------------------------------------
          156┆ <iframe src="<?php echo $lDocumentToBeFramed; ?>" width="700px" height="500px"></iframe>
    
    
          Taint comes from:
    
           79┆ $lDocumentToBeFramed = $_GET["PathToDocument"];
    
    
          Taint flows through these intermediate variables:
    
           79┆ $lDocumentToBeFramed = $_GET["PathToDocument"];
    
    
                This is how taint reaches the sink:
    
          156┆ <iframe src="<?php echo $lDocumentToBeFramed; ?>" width="700px" height="500px"></iframe>
    
                
    src/echo.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          142┆ echo '<div class="report-header">Results for '.$lMessageText.'</div>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
           51┆ $lMessageText = $lMessage;                 //allow XSS by not encoding output
    
    
                This is how taint reaches the sink:
    
          142┆ echo '<div class="report-header">Results for '.$lMessageText.'</div>';
    
    
            ⋮┆----------------------------------------
          145┆ echo '<pre class="output">'.$lMessageText.'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
           51┆ $lMessageText = $lMessage;                 //allow XSS by not encoding output
    
    
                This is how taint reaches the sink:
    
          145┆ echo '<pre class="output">'.$lMessageText.'</pre>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.injection.tainted-exec.tainted-exec
          User input is passed to a function that executes a shell command. This can lead to remote code
          execution.                                                                                    
          Details: https://sg.run/kxEEz                                                                 
                                                                                                        
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❯❱ php.lang.security.tainted-command-injection.tainted-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input that is used respectively as system commands or   
          command arguments.                                                                                  
          Details: https://sg.run/Bpj2                                                                        
                                                                                                              
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-exec.tainted-exec
          Executing non-constant commands. This can lead to command injection. You should use
          `escapeshellarg()` when using command.                                             
          Details: https://sg.run/JAkP                                                       
                                                                                             
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.laravel.security.laravel-command-injection.laravel-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input when used respectively as system commands or      
          command arguments.                                                                                  
          Details: https://sg.run/JPYR                                                                        
                                                                                                              
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
                This is how taint reaches the sink:
    
          148┆ echo '<pre class="output">'.shell_exec("echo " . $lMessage).'</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          153┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lMessageText);
    
    
          Taint comes from:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
    
          Taint flows through these intermediate variables:
    
           45┆ $lProtectAgainstMethodTampering?$lMessage = $_POST["message"]:$lMessage =
               $_REQUEST["message"];                                                    
    
           51┆ $lMessageText = $lMessage;                 //allow XSS by not encoding output
    
    
                This is how taint reaches the sink:
    
          153┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lMessageText);
    
                                
    src/edit-account-profile.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          119┆ echo '<div class="success-message">Profile updated for ' . $lUsernameText . '</div>';
    
    
          Taint comes from:
    
           57┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           57┆ $lUsername = $_POST["username"];
    
           83┆ $lUsernameText = $lUsername;
    
    
                This is how taint reaches the sink:
    
          119┆ echo '<div class="success-message">Profile updated for ' . $lUsernameText . '</div>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.injection.tainted-sql-string.tainted-sql-string
          User data flows into this manually-constructed SQL string. User data can be safely inserted into SQL
          strings using prepared statements or an object-relational mapper (ORM). Manually-constructed SQL    
          strings is a possible indicator of SQL injection, which could let an attacker steal or manipulate   
          data from the database. Instead, use prepared statements (`$mysqli->prepare("INSERT INTO test(id,   
          label) VALUES (?, ?)");`) or a safe library.                                                        
          Details: https://sg.run/lZYG                                                                        
                                                                                                              
          125┆ $LogHandler->writeToLog("Failed to update profile for: " . $lUsername);
    
    
          Taint comes from:
    
           57┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           57┆ $lUsername = $_POST["username"];
    
    
                This is how taint reaches the sink:
    
          125┆ $LogHandler->writeToLog("Failed to update profile for: " . $lUsername);
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          251┆ value="<?php echo $lUsername; ?>"
    
    
          Taint comes from:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
          158┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
          166┆ $row = $lQueryResult->fetch_object();
    
          178┆ $lUsername = $Encoder->encodeForHTML($row->username);
    
    
                This is how taint reaches the sink:
    
          251┆ value="<?php echo $lUsername; ?>"
    
    
            ⋮┆----------------------------------------
          258┆ <input type="password" name="password" size="15" value="<?php echo $lPassword; ?>"
    
    
          Taint comes from:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
          158┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
          166┆ $row = $lQueryResult->fetch_object();
    
          183┆ $lPassword = $Encoder->encodeForHTML($row->password);
    
    
                This is how taint reaches the sink:
    
          258┆ <input type="password" name="password" size="15" value="<?php echo $lPassword; ?>"
    
    
            ⋮┆----------------------------------------
          267┆ <input type="password" name="confirm_password" size="15" value="<?php echo $lPassword; ?>"
    
    
          Taint comes from:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
          158┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
          166┆ $row = $lQueryResult->fetch_object();
    
          183┆ $lPassword = $Encoder->encodeForHTML($row->password);
    
    
                This is how taint reaches the sink:
    
          267┆ <input type="password" name="confirm_password" size="15" value="<?php echo $lPassword; ?>"
    
    
            ⋮┆----------------------------------------
          275┆ value="<?php echo $lFirstName; ?>"
    
    
          Taint comes from:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
          158┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
          166┆ $row = $lQueryResult->fetch_object();
    
          179┆ $lFirstName = $Encoder->encodeForHTML($row->firstname);
    
    
                This is how taint reaches the sink:
    
          275┆ value="<?php echo $lFirstName; ?>"
    
    
            ⋮┆----------------------------------------
          283┆ value="<?php echo $lLastName; ?>"
    
    
          Taint comes from:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
          158┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
          166┆ $row = $lQueryResult->fetch_object();
    
          180┆ $lLastName = $Encoder->encodeForHTML($row->lastname);
    
    
                This is how taint reaches the sink:
    
          283┆ value="<?php echo $lLastName; ?>"
    
    
            ⋮┆----------------------------------------
          292┆ ><?php echo $lSignature; ?></textarea>
    
    
          Taint comes from:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
          158┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
          166┆ $row = $lQueryResult->fetch_object();
    
          185┆ $lSignature = $Encoder->encodeForHTML($row->mysignature);
    
    
                This is how taint reaches the sink:
    
          292┆ ><?php echo $lSignature; ?></textarea>
    
    
            ⋮┆----------------------------------------
          298┆ <?php echo $lClientID; ?>
    
    
          Taint comes from:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
          158┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
          166┆ $row = $lQueryResult->fetch_object();
    
          188┆ $lClientID = $row->client_id;       // Retrieve the client ID
    
    
                This is how taint reaches the sink:
    
          298┆ <?php echo $lClientID; ?>
    
    
            ⋮┆----------------------------------------
          311┆ <?php echo $lClientSecret; ?>
    
    
          Taint comes from:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
          137┆ $lUserUID = $_REQUEST['uid'];
    
          158┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
          166┆ $row = $lQueryResult->fetch_object();
    
          189┆ $lClientSecret = $row->client_secret;
    
    
                This is how taint reaches the sink:
    
          311┆ <?php echo $lClientSecret; ?>
    
                              
    src/hints-page-wrapper.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           66┆ <title><?php echo $lIncludeFileDescription; ?></title>
    
    
          Taint comes from:
    
           40┆ $lIncludeFileKey = $_REQUEST["level1HintIncludeFile"];
    
    
          Taint flows through these intermediate variables:
    
           40┆ $lIncludeFileKey = $_REQUEST["level1HintIncludeFile"];
    
           45┆ $lIncludeFileRecord = $SQLQueryHandler->getLevelOneHelpIncludeFile($lIncludeFileKey);
    
           48┆ $lRecord = $lIncludeFileRecord->fetch_object();
    
           50┆ $lIncludeFileDescription = $lRecord->level_1_help_include_file_description;
    
    
                This is how taint reaches the sink:
    
           66┆ <title><?php echo $lIncludeFileDescription; ?></title>
    
    
            ⋮┆----------------------------------------
           71┆ <td><?php echo $lIncludeFileDescription; ?></td>
    
    
          Taint comes from:
    
           40┆ $lIncludeFileKey = $_REQUEST["level1HintIncludeFile"];
    
    
          Taint flows through these intermediate variables:
    
           40┆ $lIncludeFileKey = $_REQUEST["level1HintIncludeFile"];
    
           45┆ $lIncludeFileRecord = $SQLQueryHandler->getLevelOneHelpIncludeFile($lIncludeFileKey);
    
           48┆ $lRecord = $lIncludeFileRecord->fetch_object();
    
           50┆ $lIncludeFileDescription = $lRecord->level_1_help_include_file_description;
    
    
                This is how taint reaches the sink:
    
           71┆ <td><?php echo $lIncludeFileDescription; ?></td>
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-path-traversal.tainted-path-traversal
          Detected user input going into a php include or require command, which can lead to path traversal   
          and sensitive data being exposed. These commands can also lead to code execution. Instead, allowlist
          files that the user can access or rigorously validate user input.                                   
          Details: https://sg.run/WGrg                                                                        
                                                                                                              
           75┆ <?php include_once './includes/hints/'.$lIncludeFile; ?>
    
    
          Taint comes from:
    
           40┆ $lIncludeFileKey = $_REQUEST["level1HintIncludeFile"];
    
    
          Taint flows through these intermediate variables:
    
           40┆ $lIncludeFileKey = $_REQUEST["level1HintIncludeFile"];
    
           45┆ $lIncludeFileRecord = $SQLQueryHandler->getLevelOneHelpIncludeFile($lIncludeFileKey);
    
           48┆ $lRecord = $lIncludeFileRecord->fetch_object();
    
           49┆ $lIncludeFile = $lRecord->level_1_help_include_file;
    
    
                This is how taint reaches the sink:
    
           75┆ <?php include_once './includes/hints/'.$lIncludeFile; ?>
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.laravel.security.laravel-path-traversal.laravel-path-traversal
          The application builds a file path from potentially untrusted data, which can lead to a path        
          traversal vulnerability. An attacker can manipulate the file path which the application uses to     
          access files. If the application does not validate user input and sanitize file paths, sensitive    
          files such as configuration or user data can be accessed, potentially creating or overwriting files.
          In PHP, this can lead to both local file inclusion (LFI) or remote file inclusion (RFI) if user     
          input reaches this statement. To prevent this vulnerability, validate and sanitize any input that is
          used to create references to file paths. Also, enforce strict file access controls. For example,    
          choose privileges allowing public-facing applications to access only the required files.            
          Details: https://sg.run/5v1K                                                                        
                                                                                                              
           75┆ <?php include_once './includes/hints/'.$lIncludeFile; ?>
    
    
          Taint comes from:
    
           40┆ $lIncludeFileKey = $_REQUEST["level1HintIncludeFile"];
    
    
          Taint flows through these intermediate variables:
    
           40┆ $lIncludeFileKey = $_REQUEST["level1HintIncludeFile"];
    
           45┆ $lIncludeFileRecord = $SQLQueryHandler->getLevelOneHelpIncludeFile($lIncludeFileKey);
    
           48┆ $lRecord = $lIncludeFileRecord->fetch_object();
    
           49┆ $lIncludeFile = $lRecord->level_1_help_include_file;
    
    
                This is how taint reaches the sink:
    
           75┆ <?php include_once './includes/hints/'.$lIncludeFile; ?>
    
                                             
    src/includes/hints/hints-menu-wrapper.inc
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           38┆ echo
           39┆    '<div class="hint-header">'.
           40┆    '<img src="images/link-icon-16-16.png" style="margin-right: 5px;" />'.
           41┆    '<a class="hint-header" href="hints-page-wrapper.php?level1HintIncludeFile='.
           42┆            $lRecord->level_1_help_include_file_key.
           43┆    '" title="Click to open '.$lRecord->level_1_help_include_file_description.' hint in new
               tab" target="_blank" />'.                                                                 
           44┆            $lRecord->level_1_help_include_file_description.
           45┆    '</a>'.
           46┆    '</div>';
    
    
          Taint comes from:
    
           29┆ $lPageName = $_GET["page"];
    
    
          Taint flows through these intermediate variables:
    
           29┆ $lPageName = $_GET["page"];
    
           34┆ $lIncludeFileRecords = $SQLQueryHandler->getPageLevelOneHelpIncludeFiles($lPageName);
    
           37┆ while($lRecord = $lIncludeFileRecords->fetch_object()){
    
    
                This is how taint reaches the sink:
    
           38┆ echo
    
           39┆    '<div class="hint-header">'.
    
           40┆    '<img src="images/link-icon-16-16.png" style="margin-right: 5px;" />'.
    
           41┆    '<a class="hint-header" href="hints-page-wrapper.php?level1HintIncludeFile='.
    
           42┆            $lRecord->level_1_help_include_file_key.
    
           43┆    '" title="Click to open '.$lRecord->level_1_help_include_file_description.' hint in new
               tab" target="_blank" />'.                                                                 
    
           44┆            $lRecord->level_1_help_include_file_description.
    
           45┆    '</a>'.
    
           46┆    '</div>';
    
                                   
    src/includes/hints/jwt-hint.inc
   ❯❯❱ generic.secrets.security.detected-jwt-token.detected-jwt-token
          JWT token detected          
          Details: https://sg.run/05N5
                                      
           46┆ echo 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9tdXRpbGxpZGFlLmxvY2FsIiwi
               YXVkIjoiaHR0cDpcL1wvbXV0aWxsaWRhZS5sb2NhbCIsImlhdCI6MTYxNDc4MTcwMCwiZXhwIjoxNjE0NzgzNTAwLCJ
               1c2VyaWQiOiIyNCJ9.2tkqvTgkNm4k8-L9MTIVIo7fdT1R53R_g7SO5QUCaFE' | cut -d. -f1 | base64 -d   
            ⋮┆----------------------------------------
           50┆ echo 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9tdXRpbGxpZGFlLmxvY2FsIiwi
               YXVkIjoiaHR0cDpcL1wvbXV0aWxsaWRhZS5sb2NhbCIsImlhdCI6MTYxNDc4MTcwMCwiZXhwIjoxNjE0NzgzNTAwLCJ
               1c2VyaWQiOiIyNCJ9.2tkqvTgkNm4k8-L9MTIVIo7fdT1R53R_g7SO5QUCaFE' | cut -d. -f2 | base64 -d   
            ⋮┆----------------------------------------
           76┆ echo 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9tdXRpbGxpZGFlLmxvY2FsIiwi
               YXVkIjoiaHR0cDpcL1wvbXV0aWxsaWRhZS5sb2NhbCIsImlhdCI6MTYxNDc4NDE3NiwiZXhwIjoxNjE0Nzg1OTc2LCJ
               1c2VyaWQiOiIyNCJ9.9rMf6Hd17Jwev3Sk2YG2CUzz9uEUOBFfImxYAE_KVpg' > token                     
            ⋮┆----------------------------------------
          100┆ New Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbXV0aWxsaWRhZS5sb2NhbCI
               sImF1ZCI6Imh0dHA6Ly9tdXRpbGxpZGFlLmxvY2FsIiwiaWF0IjoxNjE0Nzg0MTc2LCJleHAiOjE2MTQ3ODU5NzYsIn
               VzZXJpZCI6IjEifQ.kiTnwqecZE3XJP6I2frMKiDnI10Ajb0gThUFWX2s4tw                               
                                                  
    src/includes/pop-up-help-context-generator.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           26┆ echo '     <div class="help-text-header">
           27┆            Hack with confidence.
           28┆            <br/>
           29┆            Page ' . $lPageName . ' is vulnerable to at least the following:</div>';
    
    
          Taint comes from:
    
           20┆ $lPageName = $_GET["pagename"];
    
    
          Taint flows through these intermediate variables:
    
           20┆ $lPageName = $_GET["pagename"];
    
    
                This is how taint reaches the sink:
    
           26┆ echo '     <div class="help-text-header">
    
           27┆            Hack with confidence.
    
           28┆            <br/>
    
           29┆            Page ' . $lPageName . ' is vulnerable to at least the following:</div>';
    
    
            ⋮┆----------------------------------------
           32┆ echo $row->help_text;
    
    
          Taint comes from:
    
           20┆ $lPageName = $_GET["pagename"];
    
    
          Taint flows through these intermediate variables:
    
           20┆ $lPageName = $_GET["pagename"];
    
           21┆ $lQueryResult = $SQLQueryHandler->getPageHelpTexts($lPageName);
    
           31┆ while($row = $lQueryResult->fetch_object()){
    
    
                This is how taint reaches the sink:
    
           32┆ echo $row->help_text;
    
    
            ⋮┆----------------------------------------
           35┆ echo '     <div class="help-text-header">
           36┆            Page ' . $lPageName . ' does not have any help documentation.</div>';
    
    
          Taint comes from:
    
           20┆ $lPageName = $_GET["pagename"];
    
    
          Taint flows through these intermediate variables:
    
           20┆ $lPageName = $_GET["pagename"];
    
    
                This is how taint reaches the sink:
    
           35┆ echo '     <div class="help-text-header">
    
           36┆            Page ' . $lPageName . ' does not have any help documentation.</div>';
    
    
            ⋮┆----------------------------------------
           42┆ echo $CustomErrorHandler->FormatError($e, "Error selecting help text entries for page " .
               $lPageName);                                                                             
    
    
          Taint comes from:
    
           20┆ $lPageName = $_GET["pagename"];
    
    
          Taint flows through these intermediate variables:
    
           20┆ $lPageName = $_GET["pagename"];
    
    
                This is how taint reaches the sink:
    
           42┆ echo $CustomErrorHandler->FormatError($e, "Error selecting help text entries for page " .
               $lPageName);                                                                             
    
                                     
    src/includes/process-commands.php
   ❯❯❱ php.lang.security.taint-cookie-http-false.taint-cookie-http-false
          HttpOnly cookie flag is explicitly disabled. This will cause cookies to be transmitted over         
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/5qrX                                                                        
                                                                                                              
           71┆ setcookie("uid", "deleted", $l_cookie_options);
    
    
          Taint comes from:
    
           51┆ $l_cookie_options = array (
    
           52┆     'expires' => time()-3600,    // 0 means session cookie
    
           53┆     'path' => '/',               // '/' means entire domain
    
           54┆     //'domain' => '.example.com', // default is current domain
    
           55┆     'secure' => FALSE,           // true or false
    
           56┆     'httponly' => FALSE,         // true or false
    
           57┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
           58┆ );
    
    
          Taint flows through these intermediate variables:
    
           51┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
           71┆ setcookie("uid", "deleted", $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-secure-false.taint-cookie-secure-false
          Secure cookie flag is explicitly disabled. This will cause cookies to be transmitted over           
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/GJx2                                                                        
                                                                                                              
           71┆ setcookie("uid", "deleted", $l_cookie_options);
    
    
          Taint comes from:
    
           51┆ $l_cookie_options = array (
    
           52┆     'expires' => time()-3600,    // 0 means session cookie
    
           53┆     'path' => '/',               // '/' means entire domain
    
           54┆     //'domain' => '.example.com', // default is current domain
    
           55┆     'secure' => FALSE,           // true or false
    
           56┆     'httponly' => FALSE,         // true or false
    
           57┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
           58┆ );
    
    
          Taint flows through these intermediate variables:
    
           51┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
           71┆ setcookie("uid", "deleted", $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-http-false.taint-cookie-http-false
          HttpOnly cookie flag is explicitly disabled. This will cause cookies to be transmitted over         
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/5qrX                                                                        
                                                                                                              
           72┆ setcookie("username", "deleted", $l_cookie_options);
    
    
          Taint comes from:
    
           51┆ $l_cookie_options = array (
    
           52┆     'expires' => time()-3600,    // 0 means session cookie
    
           53┆     'path' => '/',               // '/' means entire domain
    
           54┆     //'domain' => '.example.com', // default is current domain
    
           55┆     'secure' => FALSE,           // true or false
    
           56┆     'httponly' => FALSE,         // true or false
    
           57┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
           58┆ );
    
    
          Taint flows through these intermediate variables:
    
           51┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
           72┆ setcookie("username", "deleted", $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-secure-false.taint-cookie-secure-false
          Secure cookie flag is explicitly disabled. This will cause cookies to be transmitted over           
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/GJx2                                                                        
                                                                                                              
           72┆ setcookie("username", "deleted", $l_cookie_options);
    
    
          Taint comes from:
    
           51┆ $l_cookie_options = array (
    
           52┆     'expires' => time()-3600,    // 0 means session cookie
    
           53┆     'path' => '/',               // '/' means entire domain
    
           54┆     //'domain' => '.example.com', // default is current domain
    
           55┆     'secure' => FALSE,           // true or false
    
           56┆     'httponly' => FALSE,         // true or false
    
           57┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
           58┆ );
    
    
          Taint flows through these intermediate variables:
    
           51┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
           72┆ setcookie("username", "deleted", $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-http-false.taint-cookie-http-false
          HttpOnly cookie flag is explicitly disabled. This will cause cookies to be transmitted over         
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/5qrX                                                                        
                                                                                                              
          112┆ setcookie('showhints', $l_showhints, $l_cookie_options);
    
    
          Taint comes from:
    
           98┆ $l_cookie_options = array (
    
           99┆     'expires' => 0,              // 0 means session cookie
    
          100┆     'path' => '/',               // '/' means entire domain
    
          101┆     //'domain' => '.example.com', // default is current domain
    
          102┆     'secure' => FALSE,           // true or false
    
          103┆     'httponly' => FALSE,         // true or false
    
          104┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
          105┆ );
    
    
          Taint flows through these intermediate variables:
    
           98┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
          112┆ setcookie('showhints', $l_showhints, $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-secure-false.taint-cookie-secure-false
          Secure cookie flag is explicitly disabled. This will cause cookies to be transmitted over           
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/GJx2                                                                        
                                                                                                              
          112┆ setcookie('showhints', $l_showhints, $l_cookie_options);
    
    
          Taint comes from:
    
           98┆ $l_cookie_options = array (
    
           99┆     'expires' => 0,              // 0 means session cookie
    
          100┆     'path' => '/',               // '/' means entire domain
    
          101┆     //'domain' => '.example.com', // default is current domain
    
          102┆     'secure' => FALSE,           // true or false
    
          103┆     'httponly' => FALSE,         // true or false
    
          104┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
          105┆ );
    
    
          Taint flows through these intermediate variables:
    
           98┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
          112┆ setcookie('showhints', $l_showhints, $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-http-false.taint-cookie-http-false
          HttpOnly cookie flag is explicitly disabled. This will cause cookies to be transmitted over         
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/5qrX                                                                        
                                                                                                              
          157┆ setcookie('showhints', "1", $l_cookie_options);
    
    
          Taint comes from:
    
          149┆ $l_cookie_options = array (
    
          150┆     'expires' => 0,              // 0 means session cookie
    
          151┆     'path' => '/',               // '/' means entire domain
    
          152┆     //'domain' => '.example.com', // default is current domain
    
          153┆     'secure' => false,           // true or false
    
          154┆     'httponly' => false,         // true or false
    
          155┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
          156┆ );
    
    
          Taint flows through these intermediate variables:
    
          149┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
          157┆ setcookie('showhints', "1", $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-secure-false.taint-cookie-secure-false
          Secure cookie flag is explicitly disabled. This will cause cookies to be transmitted over           
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/GJx2                                                                        
                                                                                                              
          157┆ setcookie('showhints', "1", $l_cookie_options);
    
    
          Taint comes from:
    
          149┆ $l_cookie_options = array (
    
          150┆     'expires' => 0,              // 0 means session cookie
    
          151┆     'path' => '/',               // '/' means entire domain
    
          152┆     //'domain' => '.example.com', // default is current domain
    
          153┆     'secure' => false,           // true or false
    
          154┆     'httponly' => false,         // true or false
    
          155┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
          156┆ );
    
    
          Taint flows through these intermediate variables:
    
          149┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
          157┆ setcookie('showhints', "1", $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-http-false.taint-cookie-http-false
          HttpOnly cookie flag is explicitly disabled. This will cause cookies to be transmitted over         
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/5qrX                                                                        
                                                                                                              
          176┆ setcookie('showhints', "0", $l_cookie_options);
    
    
          Taint comes from:
    
          149┆ $l_cookie_options = array (
    
          150┆     'expires' => 0,              // 0 means session cookie
    
          151┆     'path' => '/',               // '/' means entire domain
    
          152┆     //'domain' => '.example.com', // default is current domain
    
          153┆     'secure' => false,           // true or false
    
          154┆     'httponly' => false,         // true or false
    
          155┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
          156┆ );
    
    
          Taint flows through these intermediate variables:
    
          149┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
          176┆ setcookie('showhints', "0", $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-secure-false.taint-cookie-secure-false
          Secure cookie flag is explicitly disabled. This will cause cookies to be transmitted over           
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/GJx2                                                                        
                                                                                                              
          176┆ setcookie('showhints', "0", $l_cookie_options);
    
    
          Taint comes from:
    
          149┆ $l_cookie_options = array (
    
          150┆     'expires' => 0,              // 0 means session cookie
    
          151┆     'path' => '/',               // '/' means entire domain
    
          152┆     //'domain' => '.example.com', // default is current domain
    
          153┆     'secure' => false,           // true or false
    
          154┆     'httponly' => false,         // true or false
    
          155┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
          156┆ );
    
    
          Taint flows through these intermediate variables:
    
          149┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
          176┆ setcookie('showhints', "0", $l_cookie_options);
    
                                          
    src/includes/process-login-attempt.php
   ❯❯❱ php.lang.security.taint-cookie-http-false.taint-cookie-http-false
          HttpOnly cookie flag is explicitly disabled. This will cause cookies to be transmitted over         
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/5qrX                                                                        
                                                                                                              
           85┆ setcookie("username", $lUsernameCookie, $l_cookie_options);
    
    
          Taint comes from:
    
           81┆ 'secure' => false,
    
    
          Taint flows through these intermediate variables:
    
           78┆ $l_cookie_options = array(
    
    
                This is how taint reaches the sink:
    
           85┆ setcookie("username", $lUsernameCookie, $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-secure-false.taint-cookie-secure-false
          Secure cookie flag is explicitly disabled. This will cause cookies to be transmitted over           
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/GJx2                                                                        
                                                                                                              
           85┆ setcookie("username", $lUsernameCookie, $l_cookie_options);
    
    
          Taint comes from:
    
           78┆ $l_cookie_options = array(
    
           79┆     'expires' => 0,
    
           80┆     'path' => '/',
    
           81┆     'secure' => false,
    
           82┆     'httponly' => true,
    
           83┆     'samesite' => 'Strict'
    
           84┆ );
    
    
          Taint flows through these intermediate variables:
    
           78┆ $l_cookie_options = array(
    
    
                This is how taint reaches the sink:
    
           85┆ setcookie("username", $lUsernameCookie, $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-http-false.taint-cookie-http-false
          HttpOnly cookie flag is explicitly disabled. This will cause cookies to be transmitted over         
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/5qrX                                                                        
                                                                                                              
           86┆ setcookie("uid", $lRecord->cid, $l_cookie_options);
    
    
          Taint comes from:
    
           81┆ 'secure' => false,
    
    
          Taint flows through these intermediate variables:
    
           78┆ $l_cookie_options = array(
    
    
                This is how taint reaches the sink:
    
           86┆ setcookie("uid", $lRecord->cid, $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-secure-false.taint-cookie-secure-false
          Secure cookie flag is explicitly disabled. This will cause cookies to be transmitted over           
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/GJx2                                                                        
                                                                                                              
           86┆ setcookie("uid", $lRecord->cid, $l_cookie_options);
    
    
          Taint comes from:
    
           78┆ $l_cookie_options = array(
    
           79┆     'expires' => 0,
    
           80┆     'path' => '/',
    
           81┆     'secure' => false,
    
           82┆     'httponly' => true,
    
           83┆     'samesite' => 'Strict'
    
           84┆ );
    
    
          Taint flows through these intermediate variables:
    
           78┆ $l_cookie_options = array(
    
    
                This is how taint reaches the sink:
    
           86┆ setcookie("uid", $lRecord->cid, $l_cookie_options);
    
                 
    src/index.php
   ❯❯❱ php.lang.security.taint-cookie-http-false.taint-cookie-http-false
          HttpOnly cookie flag is explicitly disabled. This will cause cookies to be transmitted over         
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/5qrX                                                                        
                                                                                                              
          141┆ setcookie('showhints', $l_showhints, $l_cookie_options);
    
    
          Taint comes from:
    
          124┆ $l_cookie_options = array (
    
          125┆     'expires' => 0,              // 0 means session cookie
    
          126┆     'path' => '/',               // '/' means entire domain
    
          127┆     //'domain' => '.example.com', // default is current domain
    
          128┆     'secure' => false,           // true or false
    
          129┆     'httponly' => false,         // true or false
    
          130┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
          131┆ );
    
    
          Taint flows through these intermediate variables:
    
          124┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
          141┆ setcookie('showhints', $l_showhints, $l_cookie_options);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.taint-cookie-secure-false.taint-cookie-secure-false
          Secure cookie flag is explicitly disabled. This will cause cookies to be transmitted over           
          unencrypted HTTP connections which can allow theft of confidential user data such as session tokens.
          Details: https://sg.run/GJx2                                                                        
                                                                                                              
          141┆ setcookie('showhints', $l_showhints, $l_cookie_options);
    
    
          Taint comes from:
    
          124┆ $l_cookie_options = array (
    
          125┆     'expires' => 0,              // 0 means session cookie
    
          126┆     'path' => '/',               // '/' means entire domain
    
          127┆     //'domain' => '.example.com', // default is current domain
    
          128┆     'secure' => false,           // true or false
    
          129┆     'httponly' => false,         // true or false
    
          130┆     'samesite' => 'Lax'          // None || Lax  || Strict
    
          131┆ );
    
    
          Taint flows through these intermediate variables:
    
          124┆ $l_cookie_options = array (
    
    
                This is how taint reaches the sink:
    
          141┆ setcookie('showhints', $l_showhints, $l_cookie_options);
    
                                               
    src/javascript/ddsmoothmenu/ddsmoothmenu.js
   ❯❯❱ javascript.browser.security.insecure-document-method.insecure-document-method
          User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern
          that can lead to XSS vulnerabilities                                                                
          Details: https://sg.run/LwA9                                                                        
                                                                                                              
          137┆ document.write('<style type="text/css">\n'
          138┆    +mainselector+' ul li a {background:'+setting.customtheme[0]+';}\n'
          139┆    +mainmenuid+' ul li a:hover {background:'+setting.customtheme[1]+';}\n'
          140┆ +'</style>')
   
    ❯❱ typescript.react.security.audit.react-unsanitized-method.react-unsanitized-method
          Detection of write from non-constant definition. This can inadvertently expose users to cross-site
          scripting (XSS) attacks if this comes from user-provided input. If you have to use write, consider
          using a sanitization library such as DOMPurify to sanitize your HTML.                             
          Details: https://sg.run/E5x8                                                                      
                                                                                                            
          137┆ document.write('<style type="text/css">\n'
          138┆    +mainselector+' ul li a {background:'+setting.customtheme[0]+';}\n'
          139┆    +mainmenuid+' ul li a:hover {background:'+setting.customtheme[1]+';}\n'
          140┆ +'</style>')
    
    
          Taint comes from:
    
          135┆ var mainmenuid='#'+setting.mainmenuid
    
    
          Taint flows through these intermediate variables:
    
          135┆ var mainmenuid='#'+setting.mainmenuid
    
    
                This is how taint reaches the sink:
    
          137┆ document.write('<style type="text/css">\n'
    
          138┆    +mainselector+' ul li a {background:'+setting.customtheme[0]+';}\n'
    
          139┆    +mainmenuid+' ul li a:hover {background:'+setting.customtheme[1]+';}\n'
    
          140┆ +'</style>')
    
                                   
    src/javascript/jQuery/jquery.js
   ❯❯❱ javascript.browser.security.insecure-document-method.insecure-document-method
          User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern
          that can lead to XSS vulnerabilities                                                                
          Details: https://sg.run/LwA9                                                                        
                                                                                                              
          3849┆ div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
   
    ❯❱ javascript.lang.security.audit.prototype-pollution.prototype-pollution-loop.prototype-pollution-loop
          Possibility of prototype polluting function detected. By adding or modifying attributes of an object
          prototype, it is possible to create attributes that exist on every object, or replace critical      
          attributes with malicious ones. This can be problematic if the software depends on existence or non-
          existence of certain attributes, or uses pre-defined attributes of object prototype (such as        
          hasOwnProperty, toString or valueOf). Possible mitigations might be: freezing the object prototype, 
          using an object without prototypes (via Object.create(null) ), blocking modifications of attributes 
          that resolve to object prototype, using Map instead of object.                                      
          Details: https://sg.run/w1DB                                                                        
                                                                                                              
          4754┆ while ( (elem = elem[ dir ]) ) {
            ⋮┆----------------------------------------
          4768┆ while ( (elem = elem[ dir ]) ) {
            ⋮┆----------------------------------------
          4787┆ while ( (elem = elem[ dir ]) ) {
            ⋮┆----------------------------------------
          5597┆ cur = cur[dir];
   
   ❯❯❱ javascript.browser.security.insecure-document-method.insecure-document-method
          User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern
          that can lead to XSS vulnerabilities                                                                
          Details: https://sg.run/LwA9                                                                        
                                                                                                              
          5893┆ elem.innerHTML = value;
            ⋮┆----------------------------------------
          6091┆ dest.outerHTML = src.outerHTML;
            ⋮┆----------------------------------------
          6099┆ dest.innerHTML = src.innerHTML;
            ⋮┆----------------------------------------
          6239┆ fragmentDiv.innerHTML = elem.outerHTML;
            ⋮┆----------------------------------------
          6325┆ div.innerHTML = wrap[1] + elem + wrap[2];
                                                                       
    src/labs/lab-files/command-injection-lab-files/simple-web-shell.php
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
          Taint comes from:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
                This is how taint reaches the sink:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.injection.tainted-exec.tainted-exec
          User input is passed to a function that executes a shell command. This can lead to remote code
          execution.                                                                                    
          Details: https://sg.run/kxEEz                                                                 
                                                                                                        
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
          Taint comes from:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
                This is how taint reaches the sink:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
            ⋮┆----------------------------------------
   
   ❯❯❯❱ php.lang.security.tainted-command-injection.tainted-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input that is used respectively as system commands or   
          command arguments.                                                                                  
          Details: https://sg.run/Bpj2                                                                        
                                                                                                              
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
          Taint comes from:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
                This is how taint reaches the sink:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-exec.tainted-exec
          Executing non-constant commands. This can lead to command injection. You should use
          `escapeshellarg()` when using command.                                             
          Details: https://sg.run/JAkP                                                       
                                                                                             
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
          Taint comes from:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
                This is how taint reaches the sink:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-user-input-in-php-script.tainted-user-input-in-php-script
          Untrusted input could be used to tamper with a web page rendering, which can lead to a Cross-site  
          scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted input executes malicious   
          JavaScript code, leading to issues such as account compromise and sensitive information leakage. To
          prevent this vulnerability, validate the user input, perform contextual output encoding or sanitize
          the input. In PHP you can encode or sanitize user input with `htmlspecialchars` or use automatic   
          context-aware escaping with a template engine such as Latte.                                       
          Details: https://sg.run/PKkY                                                                       
                                                                                                             
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
          Taint comes from:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
                This is how taint reaches the sink:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.laravel.security.laravel-command-injection.laravel-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input when used respectively as system commands or      
          command arguments.                                                                                  
          Details: https://sg.run/JPYR                                                                        
                                                                                                              
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
          Taint comes from:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
    
                This is how taint reaches the sink:
    
            1┆ <?php echo '<pre>'.shell_exec($_GET['cmd']).'</pre>'; ?>
    
                                                      
    src/labs/lab-files/cookie-lab-files/same-site.html
    ❯❱ html.security.plaintext-http-link.plaintext-http-link
          This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.
          Details: https://sg.run/RA5q                                                        
                                                                                              
            7┆ <a href="http://mutillidae.localhost/" >Click Me to See</a>
                                                                           
    src/labs/lab-files/cross-site-scripting-lab-files/phishing-webpage.html
    ❯❱ html.security.plaintext-http-link.plaintext-http-link
          This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.
          Details: https://sg.run/RA5q                                                        
                                                                                              
            6┆ <a href="http://mutillidae.localhost/index.php?page=echo.php&message=%3c%73%63%72%69%70%74%
               3e%0a%09%76%61%72%20%6c%58%4d%4c%48%54%54%50%3b%0a%09%74%72%79%7b%20%0a%09%09%76%61%72%20%6
               c%44%61%74%61%20%3d%20%22%64%61%74%61%3d%22%20%2b%20%65%6e%63%6f%64%65%55%52%49%43%6f%6d%70
               %6f%6e%65%6e%74%28%64%6f%63%75%6d%65%6e%74%2e%63%6f%6f%6b%69%65%29%3b%0a%09%09%76%61%72%20%
               6c%48%6f%73%74%20%3d%20%22%6d%75%74%69%6c%6c%69%64%61%65%2e%6c%6f%63%61%6c%22%3b%0a%09%09%7
               6%61%72%20%6c%50%72%6f%74%6f%63%6f%6c%20%3d%20%22%68%74%74%70%22%3b%0a%09%09%76%61%72%20%6c
               %46%69%6c%65%50%61%74%68%20%3d%20%22%2f%63%61%70%74%75%72%65%2d%64%61%74%61%2e%70%68%70%22%
               3b%0a%09%09%76%61%72%20%6c%41%63%74%69%6f%6e%20%3d%20%6c%50%72%6f%74%6f%63%6f%6c%20%2b%20%2
               2%3a%2f%2f%22%20%2b%20%6c%48%6f%73%74%20%2b%20%6c%46%69%6c%65%50%61%74%68%3b%0a%09%09%76%61
               %72%20%6c%4d%65%74%68%6f%64%20%3d%20%22%50%4f%53%54%22%3b%0a%0a%09%09%74%72%79%20%7b%0a%09%
               09%09%6c%58%4d%4c%48%54%54%50%20%3d%20%6e%65%77%20%41%63%74%69%76%65%58%4f%62%6a%65%63%74%2
               8%22%4d%73%78%6d%6c%32%2e%58%4d%4c%48%54%54%50%22%29%3b%20%0a%09%09%7d%63%61%74%63%68%20%28
               %65%29%20%7b%20%0a%09%09%09%74%72%79%20%7b%20%0a%09%09%09%09%6c%58%4d%4c%48%54%54%50%20%3d%
               20%6e%65%77%20%41%63%74%69%76%65%58%4f%62%6a%65%63%74%28%22%4d%69%63%72%6f%73%6f%66%74%2e%5
               8%4d%4c%48%54%54%50%22%29%3b%20%0a%09%09%09%7d%63%61%74%63%68%20%28%65%29%20%7b%20%0a%09%09
               %09%09%74%72%79%20%7b%20%0a%09%09%09%09%09%6c%58%4d%4c%48%54%54%50%20%3d%20%6e%65%77%20%58%
               4d%4c%48%74%74%70%52%65%71%75%65%73%74%28%29%3b%20%0a%09%09%09%09%7d%63%61%74%63%68%20%28%6
               5%29%20%7b%20%0a%09%09%09%09%09%61%6c%65%72%74%28%65%2e%6d%65%73%73%61%67%65%29%3b%2f%2a%46
               %6f%72%20%74%65%73%74%69%6e%67%20%6f%6e%6c%79%2a%2f%0a%09%09%09%09%7d%20%0a%09%09%09%7d%20%
               0a%09%09%7d%2f%2a%65%6e%64%20%74%72%79%2a%2f%0a%0a%09%09%6c%58%4d%4c%48%54%54%50%2e%6f%6e%7
               2%65%61%64%79%73%74%61%74%65%63%68%61%6e%67%65%20%3d%20%66%75%6e%63%74%69%6f%6e%28%29%7b%7d
               %3b%0a%09%09%6c%58%4d%4c%48%54%54%50%2e%6f%70%65%6e%28%6c%4d%65%74%68%6f%64%2c%20%6c%41%63%
               74%69%6f%6e%2c%20%74%72%75%65%29%3b%0a%09%09%6c%58%4d%4c%48%54%54%50%2e%73%65%74%52%65%71%7
               5%65%73%74%48%65%61%64%65%72%28%22%48%6f%73%74%22%2c%20%6c%48%6f%73%74%29%3b%20%0a%09%09%6c
               %58%4d%4c%48%54%54%50%2e%73%65%74%52%65%71%75%65%73%74%48%65%61%64%65%72%28%22%43%6f%6e%74%
               65%6e%74%2d%54%79%70%65%22%2c%20%22%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%2d%77%77%77%2d%6
               6%6f%72%6d%2d%75%72%6c%65%6e%63%6f%64%65%64%22%29%3b%09%09%09%0a%09%09%6c%58%4d%4c%48%54%54
               %50%2e%73%65%6e%64%28%6c%44%61%74%61%29%3b%0a%0a%09%7d%63%61%74%63%68%28%65%29%7b%0a%09%09%
               61%6c%65%72%74%28%65%2e%6d%65%73%73%61%67%65%29%3b%2f%2a%46%6f%72%20%74%65%73%74%69%6e%67%2
               0%6f%6e%6c%79%2a%2f%0a%09%7d%20%0a%3c%2f%73%63%72%69%70%74%3e%0a" >Click Me</a>            
                                                                         
    src/labs/lab-files/cross-site-scripting-lab-files/xss-mutillidae.html
    ❯❱ html.security.plaintext-http-link.plaintext-http-link
          This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.
          Details: https://sg.run/RA5q                                                        
                                                                                              
            1┆ <a href="http://mutillidae.localhost/index.php?page=echo.php&message=%3c%73%63%72%69%70%74%
               3e%61%6c%65%72%74%28%38%29%3c%2f%73%63%72%69%70%74%3e">Click Here to Win</a>               
                                                                                       
    src/labs/lab-files/insecure-direct-object-references-lab-files/simple-web-shell.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
            3┆ echo "shell_exec ".$_REQUEST["pCommand"]."\n\n";
    
    
          Taint comes from:
    
            3┆ echo "shell_exec ".$_REQUEST["pCommand"]."\n\n";
    
    
                This is how taint reaches the sink:
    
            3┆ echo "shell_exec ".$_REQUEST["pCommand"]."\n\n";
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
            4┆ echo shell_exec($_REQUEST["pCommand"]);
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.injection.tainted-exec.tainted-exec
          User input is passed to a function that executes a shell command. This can lead to remote code
          execution.                                                                                    
          Details: https://sg.run/kxEEz                                                                 
                                                                                                        
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❯❱ php.lang.security.tainted-command-injection.tainted-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input that is used respectively as system commands or   
          command arguments.                                                                                  
          Details: https://sg.run/Bpj2                                                                        
                                                                                                              
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-exec.tainted-exec
          Executing non-constant commands. This can lead to command injection. You should use
          `escapeshellarg()` when using command.                                             
          Details: https://sg.run/JAkP                                                       
                                                                                             
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.laravel.security.laravel-command-injection.laravel-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input when used respectively as system commands or      
          command arguments.                                                                                  
          Details: https://sg.run/JPYR                                                                        
                                                                                                              
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
                                                         
    src/labs/lab-files/open-ssl-lab-files/private-key.pem
   ❯❯❱ generic.secrets.security.detected-private-key.detected-private-key
          Private Key detected. This is a sensitive credential and should not be hardcoded here. Instead,
          store this in a separate, private file.                                                        
          Details: https://sg.run/b7dr                                                                   
                                                                                                         
            1┆ -----BEGIN RSA PRIVATE KEY-----
            2┆ MIISKgIBAAKCBAEAlH1pj1kxWhfJRazHPLmL+oXj3/vyXN9V6JgLE5gqFXMn+REc
                                                                       
    src/labs/lab-files/remote-file-inclusion-lab-files/passthru-rfi.php
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
    
    
          Taint comes from:
    
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
    
    
                This is how taint reaches the sink:
    
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
    
    
            ⋮┆----------------------------------------
   
   ❯❯❯❱ php.lang.security.tainted-command-injection.tainted-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input that is used respectively as system commands or   
          command arguments.                                                                                  
          Details: https://sg.run/Bpj2                                                                        
                                                                                                              
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
    
    
          Taint comes from:
    
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
    
    
                This is how taint reaches the sink:
    
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-exec.tainted-exec
          Executing non-constant commands. This can lead to command injection. You should use
          `escapeshellarg()` when using command.                                             
          Details: https://sg.run/JAkP                                                       
                                                                                             
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
    
    
          Taint comes from:
    
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
    
    
                This is how taint reaches the sink:
    
            1┆ <?php echo passthru(escapeshellcmd($_REQUEST['cmd']));?>
    
                                                                           
    src/labs/lab-files/remote-file-inclusion-lab-files/simple-web-shell.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
            3┆ echo "shell_exec ".$_REQUEST["pCommand"]."\n\n";
    
    
          Taint comes from:
    
            3┆ echo "shell_exec ".$_REQUEST["pCommand"]."\n\n";
    
    
                This is how taint reaches the sink:
    
            3┆ echo "shell_exec ".$_REQUEST["pCommand"]."\n\n";
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
            4┆ echo shell_exec($_REQUEST["pCommand"]);
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.injection.tainted-exec.tainted-exec
          User input is passed to a function that executes a shell command. This can lead to remote code
          execution.                                                                                    
          Details: https://sg.run/kxEEz                                                                 
                                                                                                        
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❯❱ php.lang.security.tainted-command-injection.tainted-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input that is used respectively as system commands or   
          command arguments.                                                                                  
          Details: https://sg.run/Bpj2                                                                        
                                                                                                              
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-exec.tainted-exec
          Executing non-constant commands. This can lead to command injection. You should use
          `escapeshellarg()` when using command.                                             
          Details: https://sg.run/JAkP                                                       
                                                                                             
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.laravel.security.laravel-command-injection.laravel-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input when used respectively as system commands or      
          command arguments.                                                                                  
          Details: https://sg.run/JPYR                                                                        
                                                                                                              
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
          Taint comes from:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
    
                This is how taint reaches the sink:
    
            4┆ echo shell_exec($_REQUEST["pCommand"]);
    
                 
    src/login.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           92┆ <input type="hidden" name="redirectPage" value="<?php echo $lRedirectPage; ?>">
    
    
          Taint comes from:
    
           24┆ $lRedirectPage = isset($_GET['redirectPage']) ? $_GET['redirectPage'] : '';
    
    
          Taint flows through these intermediate variables:
    
           24┆ $lRedirectPage = isset($_GET['redirectPage']) ? $_GET['redirectPage'] : '';
    
    
                This is how taint reaches the sink:
    
           92┆ <input type="hidden" name="redirectPage" value="<?php echo $lRedirectPage; ?>">
    
                                
    src/pen-test-tool-lookup.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          151┆ echo "var gPenTestToolsJSONString = '" . $lPenTestToolsJSON . "'";
    
    
          Taint comes from:
    
           86┆ $lPostedToolID = $_POST["ToolID"];
    
    
          Taint flows through these intermediate variables:
    
           86┆ $lPostedToolID = $_POST["ToolID"];
    
          105┆ $lPenTestToolsJSON =
    
    
                This is how taint reaches the sink:
    
          151┆ echo "var gPenTestToolsJSONString = '" . $lPenTestToolsJSON . "'";
    
                   
    src/phpinfo.php
   ❯❯❱ php.lang.security.phpinfo-use.phpinfo-use
          The 'phpinfo' function may reveal sensitive information about your environment.
          Details: https://sg.run/W82E                                                   
                                                                                         
           29┆ echo phpinfo(INFO_ALL);
                    
    src/register.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          119┆ echo '<h2 class="success-message">Account created for ' . $lUsernameText .'.
               '.$lRowsAffected.' rows inserted.</h2>';                                    
    
    
          Taint comes from:
    
           61┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           61┆ $lUsername = $_POST["username"];
    
           82┆ $lUsernameText = $lUsername;
    
    
                This is how taint reaches the sink:
    
          119┆ echo '<h2 class="success-message">Account created for ' . $lUsernameText .'.
               '.$lRowsAffected.' rows inserted.</h2>';                                    
    
                    
    src/repeater.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          203┆ <td colspan="2" class="hint-header"><?php echo $lBuffer; ?></td>
    
    
          Taint comes from:
    
           47┆ $lStringToRepeat = $_POST["string_to_repeat"];
    
    
          Taint flows through these intermediate variables:
    
           47┆ $lStringToRepeat = $_POST["string_to_repeat"];
    
           86┆ $lBuffer = str_repeat($lStringToRepeat, (integer)$lTimesToRepeatString);
    
    
                This is how taint reaches the sink:
    
          203┆ <td colspan="2" class="hint-header"><?php echo $lBuffer; ?></td>
    
                                
    src/set-background-color.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           46┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lBackgroundColor);
    
    
          Taint comes from:
    
           39┆ $lBackgroundColor = $Encoder->encodeForCSS($_POST["background_color"]);
    
    
          Taint flows through these intermediate variables:
    
           39┆ $lBackgroundColor = $Encoder->encodeForCSS($_POST["background_color"]);
    
    
                This is how taint reaches the sink:
    
           46┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lBackgroundColor);
    
    
            ⋮┆----------------------------------------
           91┆ style="background-color:#<?php echo $lBackgroundColor; ?>"
    
    
          Taint comes from:
    
           39┆ $lBackgroundColor = $Encoder->encodeForCSS($_POST["background_color"]);
    
    
          Taint flows through these intermediate variables:
    
           39┆ $lBackgroundColor = $Encoder->encodeForCSS($_POST["background_color"]);
    
    
                This is how taint reaches the sink:
    
           91┆ style="background-color:#<?php echo $lBackgroundColor; ?>"
    
    
            ⋮┆----------------------------------------
          125┆ The current background color is <?php echo $lBackgroundColorText; ?>
    
    
          Taint comes from:
    
           40┆ $lBackgroundColorText = $Encoder->encodeForHTML($_POST["background_color"]);
    
    
          Taint flows through these intermediate variables:
    
           40┆ $lBackgroundColorText = $Encoder->encodeForHTML($_POST["background_color"]);
    
    
                This is how taint reaches the sink:
    
          125┆ The current background color is <?php echo $lBackgroundColorText; ?>
    
                         
    src/source-viewer.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           81┆ <input type="hidden" name="page" value="<?php echo $_REQUEST['page']?>">
    
    
          Taint comes from:
    
           81┆ <input type="hidden" name="page" value="<?php echo $_REQUEST['page']?>">
    
    
                This is how taint reaches the sink:
    
           81┆ <input type="hidden" name="page" value="<?php echo $_REQUEST['page']?>">
    
    
            ⋮┆----------------------------------------
          217┆ echo '<span class="label">File: '.$lFilename.'</span>';
    
    
          Taint comes from:
    
          175┆ $pPHPFile=$Encoder->encodeForHTML($_POST["phpfile"]);
    
    
          Taint flows through these intermediate variables:
    
          175┆ $pPHPFile=$Encoder->encodeForHTML($_POST["phpfile"]);
    
          210┆ $lFilename = $laAllowedPHPFiles[$pPHPFile];
    
    
                This is how taint reaches the sink:
    
          217┆ echo '<span class="label">File: '.$lFilename.'</span>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.injection.tainted-filename.tainted-filename
          File name based on user input risks server-side request forgery.
          Details: https://sg.run/Ayqp                                    
                                                                          
          219┆ highlight_file($lFilename);
    
    
          Taint comes from:
    
          175┆ $pPHPFile=$Encoder->encodeForHTML($_POST["phpfile"]);
    
    
          Taint flows through these intermediate variables:
    
          175┆ $pPHPFile=$Encoder->encodeForHTML($_POST["phpfile"]);
    
          210┆ $lFilename = $laAllowedPHPFiles[$pPHPFile];
    
    
                This is how taint reaches the sink:
    
          219┆ highlight_file($lFilename);
    
                         
    src/styling-frame.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           56┆ <iframe src="<?php echo $lPageToFrame; ?>"
    
    
          Taint comes from:
    
           29┆ $lPageToFrame = $_GET["page-to-frame"];
    
    
          Taint flows through these intermediate variables:
    
           29┆ $lPageToFrame = $_GET["page-to-frame"];
    
    
                This is how taint reaches the sink:
    
           56┆ <iframe src="<?php echo $lPageToFrame; ?>"
    
                   
    src/styling.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           69┆ <title><?php echo $lPageTitle?></title>
    
    
          Taint comes from:
    
           49┆ $lPageTitle = $_GET["page-title"];
    
    
          Taint flows through these intermediate variables:
    
           49┆ $lPageTitle = $_GET["page-title"];
    
    
                This is how taint reaches the sink:
    
           69┆ <title><?php echo $lPageTitle?></title>
    
    
            ⋮┆----------------------------------------
           74┆ <tr><td><div class="page-title"><?php echo $lPageTitle?></div></td></tr>
    
    
          Taint comes from:
    
           49┆ $lPageTitle = $_GET["page-title"];
    
    
          Taint flows through these intermediate variables:
    
           49┆ $lPageTitle = $_GET["page-title"];
    
    
                This is how taint reaches the sink:
    
           74┆ <tr><td><div class="page-title"><?php echo $lPageTitle?></div></td></tr>
    
                             
    src/test-connectivity.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           93┆ echo '<div class="report-header">Results for '.$lServerURLText.'</div>';
    
    
          Taint comes from:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
          Taint flows through these intermediate variables:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
           51┆ $lServerURLText = $lServerURL;
    
    
                This is how taint reaches the sink:
    
           93┆ echo '<div class="report-header">Results for '.$lServerURLText.'</div>';
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
           94┆             echo '<pre class="output">' .
           95┆                             shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' "
               . $lServerURL) .                                                                           
           96┆                             '</pre>';
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           94┆             echo '<pre class="output">' .
           95┆                             shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' "
               . $lServerURL) .                                                                           
           96┆                             '</pre>';
    
    
          Taint comes from:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
          Taint flows through these intermediate variables:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
                This is how taint reaches the sink:
    
           94┆             echo '<pre class="output">' .
    
           95┆                             shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' "
               . $lServerURL) .                                                                           
    
           96┆                             '</pre>';
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.injection.tainted-exec.tainted-exec
          User input is passed to a function that executes a shell command. This can lead to remote code
          execution.                                                                                    
          Details: https://sg.run/kxEEz                                                                 
                                                                                                        
           95┆ shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' " . $lServerURL) .
    
    
          Taint comes from:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
          Taint flows through these intermediate variables:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
                This is how taint reaches the sink:
    
           95┆ shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' " . $lServerURL) .
    
    
            ⋮┆----------------------------------------
   
   ❯❯❯❱ php.lang.security.tainted-command-injection.tainted-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input that is used respectively as system commands or   
          command arguments.                                                                                  
          Details: https://sg.run/Bpj2                                                                        
                                                                                                              
           95┆ shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' " . $lServerURL) .
    
    
          Taint comes from:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
          Taint flows through these intermediate variables:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
                This is how taint reaches the sink:
    
           95┆ shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' " . $lServerURL) .
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-exec.tainted-exec
          Executing non-constant commands. This can lead to command injection. You should use
          `escapeshellarg()` when using command.                                             
          Details: https://sg.run/JAkP                                                       
                                                                                             
           95┆ shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' " . $lServerURL) .
    
    
          Taint comes from:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
          Taint flows through these intermediate variables:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
                This is how taint reaches the sink:
    
           95┆ shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' " . $lServerURL) .
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.laravel.security.laravel-command-injection.laravel-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input when used respectively as system commands or      
          command arguments.                                                                                  
          Details: https://sg.run/JPYR                                                                        
                                                                                                              
           95┆ shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' " . $lServerURL) .
    
    
          Taint comes from:
    
           92┆ $lCurrentOrigin = $_SERVER['HTTP_HOST'];
    
    
          Taint flows through these intermediate variables:
    
           92┆ $lCurrentOrigin = $_SERVER['HTTP_HOST'];
    
           95┆ shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' " . $lServerURL) .
    
    
                This is how taint reaches the sink:
    
           95┆ shell_exec("curl --silent -H 'Origin: http://$lCurrentOrigin' " . $lServerURL) .
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
           99┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lServerURLText);
    
    
          Taint comes from:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
    
          Taint flows through these intermediate variables:
    
           43┆ $lProtectAgainstMethodTampering?$lServerURL = $_POST["ServerURL"]:$lServerURL =
               $_REQUEST["ServerURL"];                                                        
    
           51┆ $lServerURLText = $lServerURL;
    
    
                This is how taint reaches the sink:
    
           99┆ echo $CustomErrorHandler->FormatError($e, "Input: " . $lServerURLText);
    
                            
    src/text-file-viewer.php
    ❯❱ php.lang.security.injection.tainted-filename.tainted-filename
          File name based on user input risks server-side request forgery.
          Details: https://sg.run/Ayqp                                    
                                                                          
          219┆ $handle = fopen($lURL, "r");
    
    
          Taint comes from:
    
          111┆ $pTextFile=$_POST["textfile"];
    
    
          Taint flows through these intermediate variables:
    
          111┆ $pTextFile=$_POST["textfile"];
    
          193┆ $lURL = $pTextFile;
    
    
                This is how taint reaches the sink:
    
          219┆ $handle = fopen($lURL, "r");
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          220┆ echo '<span class="label">File: '.$lTextFileDescription.'</span>';
    
    
          Taint comes from:
    
          111┆ $pTextFile=$_POST["textfile"];
    
    
          Taint flows through these intermediate variables:
    
          111┆ $pTextFile=$_POST["textfile"];
    
          193┆ $lURL = $pTextFile;
    
          202┆ $lTextFileDescription = $lURL;
    
    
                This is how taint reaches the sink:
    
          220┆ echo '<span class="label">File: '.$lTextFileDescription.'</span>';
    
    
            ⋮┆----------------------------------------
          222┆ echo stream_get_contents($handle);
    
    
          Taint comes from:
    
          111┆ $pTextFile=$_POST["textfile"];
    
    
          Taint flows through these intermediate variables:
    
          111┆ $pTextFile=$_POST["textfile"];
    
          193┆ $lURL = $pTextFile;
    
          219┆ $handle = fopen($lURL, "r");
    
    
                This is how taint reaches the sink:
    
          222┆ echo stream_get_contents($handle);
    
                       
    src/upload-file.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          157┆ echo "<div>
          158┆            <table style='width: 600px;'>
          159┆                    <tr><td class='label' colspan='2'>{$lFileUploadMessage}</td></tr>
          160┆                    <tr><td class='label' colspan='2'>{$lFileMovedMessage}</td></tr>
          161┆                    <tr><td class='label' colspan='2'>{$lValidationMessage}</td></tr>
          162┆                    <tr><td>&nbsp;</td></tr>
          163┆                    <tr><td class='label'>Original File Name</td><td>{$lFilename}</td></tr>
          164┆                    <tr><td class='label'>Temporary File
               Name</td><td>{$lFileTempName}</td></tr>                
          165┆                    <tr><td class='label'>Permanent File
               Name</td><td>{$lFilePermanentName}</td></tr>           
          166┆                    <tr><td class='label'>File Type</td><td>{$lFileType}</td></tr>
             [hid 4 additional lines, adjust with --max-lines-per-finding] 
    
    
          Taint comes from:
    
           45┆ case "CLIENT_DECIDES": $lTempDirectory = $_REQUEST["UPLOAD_DIRECTORY"];break;
    
    
          Taint flows through these intermediate variables:
    
           45┆ case "CLIENT_DECIDES": $lTempDirectory = $_REQUEST["UPLOAD_DIRECTORY"];break;
    
           56┆ $lFilePermanentName = $lTempDirectory . DIRECTORY_SEPARATOR . $lFilename;
    
          157┆ echo "<div>
    
    
                This is how taint reaches the sink:
    
          157┆ echo "<div>
    
          158┆            <table style='width: 600px;'>
    
          159┆                    <tr><td class='label' colspan='2'>{$lFileUploadMessage}</td></tr>
    
          160┆                    <tr><td class='label' colspan='2'>{$lFileMovedMessage}</td></tr>
    
          161┆                    <tr><td class='label' colspan='2'>{$lValidationMessage}</td></tr>
    
          162┆                    <tr><td>&nbsp;</td></tr>
    
          163┆                    <tr><td class='label'>Original File Name</td><td>{$lFilename}</td></tr>
    
          164┆                    <tr><td class='label'>Temporary File
               Name</td><td>{$lFileTempName}</td></tr>                
    
          165┆                    <tr><td class='label'>Permanent File
               Name</td><td>{$lFilePermanentName}</td></tr>           
    
          166┆                    <tr><td class='label'>File Type</td><td>{$lFileType}</td></tr>
    
             [hid 4 additional lines, adjust with --max-lines-per-finding] 
    
                           
    src/user-info-xpath.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          202┆ echo '<br />
          203┆      <div class="report-header">
          204┆                    Results for <span style="color:#770000;">'
          205┆            .$lHTMLUsername.
          206┆    '</span></div>';
    
    
          Taint comes from:
    
           49┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           49┆ $lUsername = $_POST["username"];
    
          188┆ $lHTMLUsername = $lUsername;
    
    
                This is how taint reaches the sink:
    
          202┆ echo '<br />
    
          203┆      <div class="report-header">
    
          204┆                    Results for <span style="color:#770000;">'
    
          205┆            .$lHTMLUsername.
    
          206┆    '</span></div>';
    
    
            ⋮┆----------------------------------------
          208┆ echo '<br /><span style="font-weight:bold;">Executed query:</span>&nbsp;' .
               $lHTMLXPathQueryString . '<br /><br />';                                   
    
    
          Taint comes from:
    
           49┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           49┆ $lUsername = $_POST["username"];
    
          181┆ $lXPathUsername = $lUsername;
    
          192┆ $lXPathQueryString = str_replace("{USERNAME}", $lXPathUsername, $lXPathQueryString);
    
          199┆ $lHTMLXPathQueryString = $lXPathQueryString;
    
    
                This is how taint reaches the sink:
    
          208┆ echo '<br /><span style="font-weight:bold;">Executed query:</span>&nbsp;' .
               $lHTMLXPathQueryString . '<br /><br />';                                   
    
    
            ⋮┆----------------------------------------
          210┆ echo $lXMLQueryResults;
    
    
          Taint comes from:
    
           49┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           49┆ $lUsername = $_POST["username"];
    
          181┆ $lXPathUsername = $lUsername;
    
          192┆ $lXPathQueryString = str_replace("{USERNAME}", $lXPathUsername, $lXPathQueryString);
    
          194┆ $lXMLQueryResults = $XMLHandler->ExecuteXPATHQuery($lXPathQueryString);
    
    
                This is how taint reaches the sink:
    
          210┆ echo $lXMLQueryResults;
    
                     
    src/user-info.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          183┆ echo '<div class="report-header">
          184┆            Results for &quot;<span style="color:#770000;">'
          185┆            .$lUsername.
          186┆            '</span>&quot;. '.$lRecordsFound.' records found.
          187┆    </div>';
    
    
          Taint comes from:
    
           46┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           46┆ $lUsername = $_POST["username"];
    
    
                This is how taint reaches the sink:
    
          183┆ echo '<div class="report-header">
    
          184┆            Results for &quot;<span style="color:#770000;">'
    
          185┆            .$lUsername.
    
          186┆            '</span>&quot;. '.$lRecordsFound.' records found.
    
          187┆    </div>';
    
    
            ⋮┆----------------------------------------
          217┆ echo "<span class=\"label\">First Name:&nbsp;</span><span>{$lFirstName}</span><br/>";
    
    
          Taint comes from:
    
           46┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           46┆ $lUsername = $_POST["username"];
    
          169┆ $lQueryResult = $SQLQueryHandler->getUserAccount($lUsername, $lPassword);
    
          191┆ while($row = $lQueryResult->fetch_object()){
    
          210┆ $lFirstName = $Encoder->encodeForHTML($row->firstname);
    
          217┆ echo "<span class=\"label\">First Name:&nbsp;</span><span>{$lFirstName}</span><br/>";
    
    
                This is how taint reaches the sink:
    
          217┆ echo "<span class=\"label\">First Name:&nbsp;</span><span>{$lFirstName}</span><br/>";
    
    
            ⋮┆----------------------------------------
          218┆ echo "<span class=\"label\">Last Name:&nbsp;</span><span>{$lLastName}</span><br/>";
    
    
          Taint comes from:
    
           46┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           46┆ $lUsername = $_POST["username"];
    
          169┆ $lQueryResult = $SQLQueryHandler->getUserAccount($lUsername, $lPassword);
    
          191┆ while($row = $lQueryResult->fetch_object()){
    
          211┆ $lLastName = $Encoder->encodeForHTML($row->lastname);
    
          218┆ echo "<span class=\"label\">Last Name:&nbsp;</span><span>{$lLastName}</span><br/>";
    
    
                This is how taint reaches the sink:
    
          218┆ echo "<span class=\"label\">Last Name:&nbsp;</span><span>{$lLastName}</span><br/>";
    
    
            ⋮┆----------------------------------------
          219┆ echo "<span class=\"label\">Username:&nbsp;</span><span>{$lUsername}</span><br/>";
    
    
          Taint comes from:
    
           46┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           46┆ $lUsername = $_POST["username"];
    
          219┆ echo "<span class=\"label\">Username:&nbsp;</span><span>{$lUsername}</span><br/>";
    
    
                This is how taint reaches the sink:
    
          219┆ echo "<span class=\"label\">Username:&nbsp;</span><span>{$lUsername}</span><br/>";
    
    
            ⋮┆----------------------------------------
          220┆ echo "<span class=\"label\">Password:&nbsp;</span><span>{$lPassword}</span><br/>";
    
    
          Taint comes from:
    
           46┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           46┆ $lUsername = $_POST["username"];
    
          169┆ $lQueryResult = $SQLQueryHandler->getUserAccount($lUsername, $lPassword);
    
          191┆ while($row = $lQueryResult->fetch_object()){
    
          208┆ $lPassword = !$lProtectAgainstPasswordLeakage ? $Encoder->encodeForHTML($row->password) :
               '';                                                                                      
    
          220┆ echo "<span class=\"label\">Password:&nbsp;</span><span>{$lPassword}</span><br/>";
    
    
                This is how taint reaches the sink:
    
          220┆ echo "<span class=\"label\">Password:&nbsp;</span><span>{$lPassword}</span><br/>";
    
    
            ⋮┆----------------------------------------
          221┆ echo "<span class=\"label\">Signature:&nbsp;</span><span>{$lSignature}</span><br/>";
    
    
          Taint comes from:
    
           46┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           46┆ $lUsername = $_POST["username"];
    
          169┆ $lQueryResult = $SQLQueryHandler->getUserAccount($lUsername, $lPassword);
    
          191┆ while($row = $lQueryResult->fetch_object()){
    
          209┆ $lSignature = $Encoder->encodeForHTML($row->mysignature);
    
          221┆ echo "<span class=\"label\">Signature:&nbsp;</span><span>{$lSignature}</span><br/>";
    
    
                This is how taint reaches the sink:
    
          221┆ echo "<span class=\"label\">Signature:&nbsp;</span><span>{$lSignature}</span><br/>";
    
    
            ⋮┆----------------------------------------
          222┆ echo "<span class=\"label\">Client ID:&nbsp;</span><span>{$lClientID}</span><br/>";
    
    
          Taint comes from:
    
           46┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           46┆ $lUsername = $_POST["username"];
    
          169┆ $lQueryResult = $SQLQueryHandler->getUserAccount($lUsername, $lPassword);
    
          191┆ while($row = $lQueryResult->fetch_object()){
    
          213┆ $lClientID = $Encoder->encodeForHTML($row->client_id);
    
          222┆ echo "<span class=\"label\">Client ID:&nbsp;</span><span>{$lClientID}</span><br/>";
    
    
                This is how taint reaches the sink:
    
          222┆ echo "<span class=\"label\">Client ID:&nbsp;</span><span>{$lClientID}</span><br/>";
    
    
            ⋮┆----------------------------------------
          223┆ echo "<span class=\"label\">Client Secret:&nbsp;</span><span>{$lClientSecret}</span><br/>";
    
    
          Taint comes from:
    
           46┆ $lUsername = $_POST["username"];
    
    
          Taint flows through these intermediate variables:
    
           46┆ $lUsername = $_POST["username"];
    
          169┆ $lQueryResult = $SQLQueryHandler->getUserAccount($lUsername, $lPassword);
    
          191┆ while($row = $lQueryResult->fetch_object()){
    
          212┆ $lClientSecret = $Encoder->encodeForHTML($row->client_secret);
    
          223┆ echo "<span class=\"label\">Client Secret:&nbsp;</span><span>{$lClientSecret}</span><br/>";
    
    
                This is how taint reaches the sink:
    
          223┆ echo "<span class=\"label\">Client Secret:&nbsp;</span><span>{$lClientSecret}</span><br/>";
    
                     
    src/user-poll.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          187┆ Your Initials:<input type="text" name="initials" <?php echo $lHTMLControlAttributes ?>
               value="<?php echo $lUserInitials; ?>"/>                                               
    
    
          Taint comes from:
    
          108┆ $lUserInitials = $_GET["initials"];
    
    
          Taint flows through these intermediate variables:
    
          108┆ $lUserInitials = $_GET["initials"];
    
    
                This is how taint reaches the sink:
    
          187┆ Your Initials:<input type="text" name="initials" <?php echo $lHTMLControlAttributes ?>
               value="<?php echo $lUserInitials; ?>"/>                                               
    
    
            ⋮┆----------------------------------------
          200┆ <?php echo $lUserChoiceMessage; ?>
    
    
          Taint comes from:
    
          107┆ $lUserChoice = $_GET["choice"];
    
    
          Taint flows through these intermediate variables:
    
          107┆ $lUserChoice = $_GET["choice"];
    
          118┆ $lUserChoiceMessage = "Your choice was {$lUserChoice}";
    
          118┆ $lUserChoiceMessage = "Your choice was {$lUserChoice}";
    
    
                This is how taint reaches the sink:
    
          200┆ <?php echo $lUserChoiceMessage; ?>
    
                                
    src/view-account-profile.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          133┆ <td><?php echo $lCID; ?></td>
    
    
          Taint comes from:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
           71┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
           79┆ $row = $lQueryResult->fetch_object();
    
           94┆ $lCID = $Encoder->encodeForHTML($row->cid);
    
    
                This is how taint reaches the sink:
    
          133┆ <td><?php echo $lCID; ?></td>
    
    
            ⋮┆----------------------------------------
          137┆ <td><?php echo $lFirstName; ?></td>
    
    
          Taint comes from:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
           71┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
           79┆ $row = $lQueryResult->fetch_object();
    
          100┆ $lFirstName = $Encoder->encodeForHTML($row->firstname);  // Encoded first name
    
    
                This is how taint reaches the sink:
    
          137┆ <td><?php echo $lFirstName; ?></td>
    
    
            ⋮┆----------------------------------------
          141┆ <td><?php echo $lLastName; ?></td>
    
    
          Taint comes from:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
           71┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
           79┆ $row = $lQueryResult->fetch_object();
    
          101┆ $lLastName = $Encoder->encodeForHTML($row->lastname);    // Encoded last name
    
    
                This is how taint reaches the sink:
    
          141┆ <td><?php echo $lLastName; ?></td>
    
    
            ⋮┆----------------------------------------
          145┆ <td><?php echo $lUsername; ?></td>
    
    
          Taint comes from:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
           71┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
           79┆ $row = $lQueryResult->fetch_object();
    
           95┆ $lUsername = $Encoder->encodeForHTML($row->username);
    
    
                This is how taint reaches the sink:
    
          145┆ <td><?php echo $lUsername; ?></td>
    
    
            ⋮┆----------------------------------------
          149┆ <td><?php echo $lPassword; ?></td>
    
    
          Taint comes from:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
           71┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
           79┆ $row = $lQueryResult->fetch_object();
    
           97┆ $lPassword = $Encoder->encodeForHTML($row->password);
    
    
                This is how taint reaches the sink:
    
          149┆ <td><?php echo $lPassword; ?></td>
    
    
            ⋮┆----------------------------------------
          153┆ <td><?php echo $lSignature; ?></td>
    
    
          Taint comes from:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
           71┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
           79┆ $row = $lQueryResult->fetch_object();
    
           99┆ $lSignature = $Encoder->encodeForHTML($row->mysignature);
    
    
                This is how taint reaches the sink:
    
          153┆ <td><?php echo $lSignature; ?></td>
    
    
            ⋮┆----------------------------------------
          161┆ <td><?php echo $lClientID; ?></td>
    
    
          Taint comes from:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
           71┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
           79┆ $row = $lQueryResult->fetch_object();
    
          104┆ $lClientID = $Encoder->encodeForHTML($row->client_id);         // Encoded client ID
    
    
                This is how taint reaches the sink:
    
          161┆ <td><?php echo $lClientID; ?></td>
    
    
            ⋮┆----------------------------------------
          165┆ <td><?php echo $lClientSecret; ?></td>
    
    
          Taint comes from:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
    
          Taint flows through these intermediate variables:
    
           44┆ $lUserUID = $_REQUEST['uid'];
    
           71┆ $lQueryResult = $SQLQueryHandler->getUserAccountByID($lUserUID);
    
           79┆ $row = $lQueryResult->fetch_object();
    
          103┆ $lClientSecret = $Encoder->encodeForHTML($row->client_secret);       // Encoded API key
    
    
                This is how taint reaches the sink:
    
          165┆ <td><?php echo $lClientSecret; ?></td>
    
                              
    src/view-someones-blog.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          163┆     echo '
          164┆            <tr class="report-header">
          165┆                    <td colspan="4">'.$lQueryResult->num_rows.' Current Blog Entries</td>
          166┆            </tr>
          167┆            <tr class="report-header">
          168┆                    <td>&nbsp;</td>
          169┆                <td>Name</td>
          170┆                <td>Date</td>
          171┆                <td>Comment</td>
          172┆        </tr>';
    
    
          Taint comes from:
    
          145┆ $lAuthor = $_POST["author"];
    
    
          Taint flows through these intermediate variables:
    
          145┆ $lAuthor = $_POST["author"];
    
          157┆ $lQueryResult = $SQLQueryHandler->getBlogRecord($lAuthor);
    
    
                This is how taint reaches the sink:
    
          163┆     echo '
    
          164┆            <tr class="report-header">
    
          165┆                    <td colspan="4">'.$lQueryResult->num_rows.' Current Blog Entries</td>
    
          166┆            </tr>
    
          167┆            <tr class="report-header">
    
          168┆                    <td>&nbsp;</td>
    
          169┆                <td>Name</td>
    
          170┆                <td>Date</td>
    
          171┆                <td>Comment</td>
    
          172┆        </tr>';
    
    
            ⋮┆----------------------------------------
          207┆ echo "<tr>
          208┆    <td>{$lRowNumber}</td>
          209┆    <td>{$lBloggerName}</td>
          210┆    <td>{$lDate}</td>
          211┆    <td>{$lComment}</td>
          212┆ </tr>\n";
    
    
          Taint comes from:
    
          145┆ $lAuthor = $_POST["author"];
    
    
          Taint flows through these intermediate variables:
    
          145┆ $lAuthor = $_POST["author"];
    
          157┆ $lQueryResult = $SQLQueryHandler->getBlogRecord($lAuthor);
    
          175┆ while($row = $lQueryResult->fetch_object()){
    
          187┆ $lBloggerName = $Encoder->encodeForHTML($row->blogger_name);
    
          207┆ echo "<tr>
    
    
                This is how taint reaches the sink:
    
          207┆ echo "<tr>
    
          208┆    <td>{$lRowNumber}</td>
    
          209┆    <td>{$lBloggerName}</td>
    
          210┆    <td>{$lDate}</td>
    
          211┆    <td>{$lComment}</td>
    
          212┆ </tr>\n";
    
                                     
    src/view-user-privilege-level.php
   ❯❯❱ php.lang.security.md5-loose-equality.md5-loose-equality
          Make sure comparisons involving md5 values are strict (use `===` not `==`) to avoid type juggling
          issues                                                                                           
          Details: https://sg.run/Do4G                                                                     
                                                                                                           
          131┆ if ($lUserIDValue == "000" && $lUserGroupIDValue == "000"){
    
    
          Taint comes from:
    
           78┆ $lCryptoKey = MD5("SecretSauce12345");
    
    
          Taint flows through these intermediate variables:
    
           78┆ $lCryptoKey = MD5("SecretSauce12345");
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
           11┆ function __xor($lHexString1, $lHexString2) {
    
           15┆ $lResult .= str_pad(dechex(hexdec(substr($lHexString1,$i,2)) ^
               hexdec(substr($lHexString2,$i,2))), 2, "0", STR_PAD_LEFT);    
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
          123┆ $lUnchainedPlaintext .= chr(hexdec(substr($lUnchainedHexText,$i,2)));
    
          127┆ $lUserIDValue = substr($lUnchainedPlaintext,4,3);
    
    
                This is how taint reaches the sink:
    
          131┆ if ($lUserIDValue == "000" && $lUserGroupIDValue == "000"){
    
    
            ⋮┆----------------------------------------
          131┆ if ($lUserIDValue == "000" && $lUserGroupIDValue == "000"){
    
    
          Taint comes from:
    
           78┆ $lCryptoKey = MD5("SecretSauce12345");
    
    
          Taint flows through these intermediate variables:
    
           78┆ $lCryptoKey = MD5("SecretSauce12345");
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
           11┆ function __xor($lHexString1, $lHexString2) {
    
           15┆ $lResult .= str_pad(dechex(hexdec(substr($lHexString1,$i,2)) ^
               hexdec(substr($lHexString2,$i,2))), 2, "0", STR_PAD_LEFT);    
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
          123┆ $lUnchainedPlaintext .= chr(hexdec(substr($lUnchainedHexText,$i,2)));
    
          128┆ $lUserGroupIDValue = substr($lUnchainedPlaintext,7,3);
    
    
                This is how taint reaches the sink:
    
          131┆ if ($lUserIDValue == "000" && $lUserGroupIDValue == "000"){
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          169┆ <td style="text-align: left;"><?php echo $lApplicationIDValue; ?></td>
    
    
          Taint comes from:
    
           73┆ $lInitializationVector = $_GET["iv"];
    
    
          Taint flows through these intermediate variables:
    
           73┆ $lInitializationVector = $_GET["iv"];
    
          115┆ $lUnchainedCiphertext = __xor($lInitializationVector, $lChainedCipherBlock);
    
           11┆ function __xor($lHexString1, $lHexString2) {
    
           15┆ $lResult .= str_pad(dechex(hexdec(substr($lHexString1,$i,2)) ^
               hexdec(substr($lHexString2,$i,2))), 2, "0", STR_PAD_LEFT);    
    
          115┆ $lUnchainedCiphertext = __xor($lInitializationVector, $lChainedCipherBlock);
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
           11┆ function __xor($lHexString1, $lHexString2) {
    
           15┆ $lResult .= str_pad(dechex(hexdec(substr($lHexString1,$i,2)) ^
               hexdec(substr($lHexString2,$i,2))), 2, "0", STR_PAD_LEFT);    
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
          123┆ $lUnchainedPlaintext .= chr(hexdec(substr($lUnchainedHexText,$i,2)));
    
          126┆ $lApplicationIDValue = substr($lUnchainedPlaintext,0,4);
    
    
                This is how taint reaches the sink:
    
          169┆ <td style="text-align: left;"><?php echo $lApplicationIDValue; ?></td>
    
    
            ⋮┆----------------------------------------
          173┆ <td style="text-align: left;"><?php echo $lUserIDValue . " ( Hint: " .
               prettyPrintStringToHex($lUserIDValue) . ")"; ?></td>                  
    
    
          Taint comes from:
    
           73┆ $lInitializationVector = $_GET["iv"];
    
    
          Taint flows through these intermediate variables:
    
           73┆ $lInitializationVector = $_GET["iv"];
    
          115┆ $lUnchainedCiphertext = __xor($lInitializationVector, $lChainedCipherBlock);
    
           11┆ function __xor($lHexString1, $lHexString2) {
    
           15┆ $lResult .= str_pad(dechex(hexdec(substr($lHexString1,$i,2)) ^
               hexdec(substr($lHexString2,$i,2))), 2, "0", STR_PAD_LEFT);    
    
          115┆ $lUnchainedCiphertext = __xor($lInitializationVector, $lChainedCipherBlock);
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
           11┆ function __xor($lHexString1, $lHexString2) {
    
           15┆ $lResult .= str_pad(dechex(hexdec(substr($lHexString1,$i,2)) ^
               hexdec(substr($lHexString2,$i,2))), 2, "0", STR_PAD_LEFT);    
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
          123┆ $lUnchainedPlaintext .= chr(hexdec(substr($lUnchainedHexText,$i,2)));
    
          127┆ $lUserIDValue = substr($lUnchainedPlaintext,4,3);
    
    
                This is how taint reaches the sink:
    
          173┆ <td style="text-align: left;"><?php echo $lUserIDValue . " ( Hint: " .
               prettyPrintStringToHex($lUserIDValue) . ")"; ?></td>                  
    
    
            ⋮┆----------------------------------------
          177┆ <td style="text-align: left;"><?php echo $lUserGroupIDValue . " ( Hint: " .
               prettyPrintStringToHex($lUserGroupIDValue) . ")"; ?></td>                  
    
    
          Taint comes from:
    
           73┆ $lInitializationVector = $_GET["iv"];
    
    
          Taint flows through these intermediate variables:
    
           73┆ $lInitializationVector = $_GET["iv"];
    
          115┆ $lUnchainedCiphertext = __xor($lInitializationVector, $lChainedCipherBlock);
    
           11┆ function __xor($lHexString1, $lHexString2) {
    
           15┆ $lResult .= str_pad(dechex(hexdec(substr($lHexString1,$i,2)) ^
               hexdec(substr($lHexString2,$i,2))), 2, "0", STR_PAD_LEFT);    
    
          115┆ $lUnchainedCiphertext = __xor($lInitializationVector, $lChainedCipherBlock);
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
           11┆ function __xor($lHexString1, $lHexString2) {
    
           15┆ $lResult .= str_pad(dechex(hexdec(substr($lHexString1,$i,2)) ^
               hexdec(substr($lHexString2,$i,2))), 2, "0", STR_PAD_LEFT);    
    
          116┆ $lUnchainedHexText = __xor($lUnchainedCiphertext, $lCryptoKey);
    
          123┆ $lUnchainedPlaintext .= chr(hexdec(substr($lUnchainedHexText,$i,2)));
    
          128┆ $lUserGroupIDValue = substr($lUnchainedPlaintext,7,3);
    
    
                This is how taint reaches the sink:
    
          177┆ <td style="text-align: left;"><?php echo $lUserGroupIDValue . " ( Hint: " .
               prettyPrintStringToHex($lUserGroupIDValue) . ")"; ?></td>                  
    
                                         
    src/webservices/rest/ws-cors-echo.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          100┆ echo json_encode([
          101┆     "TransactionID" => generateTransactionID(),
          102┆     "Message" => $lMessageText,
          103┆     "Method" => $lVerb,
          104┆     "Parameters" => [
          105┆         "GET" => $_GET,
          106┆         "POST" => $_POST
          107┆     ],
          108┆     "Max-Age" => $lMaxAge,
          109┆     "Timestamp" => date(DATE_TIME_FORMAT)
             [hid 1 additional lines, adjust with --max-lines-per-finding] 
    
    
          Taint comes from:
    
           47┆ $lMaxAge = $_GET['acma'] ?? $_POST['acma'] ?? 600;
    
    
          Taint flows through these intermediate variables:
    
           47┆ $lMaxAge = $_GET['acma'] ?? $_POST['acma'] ?? 600;
    
    
                This is how taint reaches the sink:
    
          100┆ echo json_encode([
    
          101┆     "TransactionID" => generateTransactionID(),
    
          102┆     "Message" => $lMessageText,
    
          103┆     "Method" => $lVerb,
    
          104┆     "Parameters" => [
    
          105┆         "GET" => $_GET,
    
          106┆         "POST" => $_POST
    
          107┆     ],
    
          108┆     "Max-Age" => $lMaxAge,
    
          109┆     "Timestamp" => date(DATE_TIME_FORMAT)
    
             [hid 1 additional lines, adjust with --max-lines-per-finding] 
    
                                          
    src/webservices/rest/ws-dns-lookup.php
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
          100┆ $lOutput = shell_exec($lCommand);
   
    ❯❱ php.lang.security.injection.tainted-exec.tainted-exec
          User input is passed to a function that executes a shell command. This can lead to remote code
          execution.                                                                                    
          Details: https://sg.run/kxEEz                                                                 
                                                                                                        
          100┆ $lOutput = shell_exec($lCommand);
    
    
          Taint comes from:
    
           71┆ $inputData = json_decode(file_get_contents('php://input'), true);
    
    
          Taint flows through these intermediate variables:
    
           71┆ $inputData = json_decode(file_get_contents('php://input'), true);
    
           71┆ $inputData = json_decode(file_get_contents('php://input'), true);
    
           78┆ $lHostname = $inputData['hostname'] ?? '';
    
           78┆ $lHostname = $inputData['hostname'] ?? '';
    
           96┆ $lCommand = $lProtectAgainstCommandInjection
    
           96┆ $lCommand = $lProtectAgainstCommandInjection
    
    
                This is how taint reaches the sink:
    
          100┆ $lOutput = shell_exec($lCommand);
    
                                    
    src/webservices/rest/ws-echo.php
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
           95┆ $lOutput = shell_exec($lCommand);
   
    ❯❱ php.lang.security.injection.tainted-exec.tainted-exec
          User input is passed to a function that executes a shell command. This can lead to remote code
          execution.                                                                                    
          Details: https://sg.run/kxEEz                                                                 
                                                                                                        
           95┆ $lOutput = shell_exec($lCommand);
    
    
          Taint comes from:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
    
          Taint flows through these intermediate variables:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
           88┆ $lCommand = "echo " . $lMessage; // Vulnerable: Direct input usage
    
    
                This is how taint reaches the sink:
    
           95┆ $lOutput = shell_exec($lCommand);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❯❱ php.lang.security.tainted-command-injection.tainted-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input that is used respectively as system commands or   
          command arguments.                                                                                  
          Details: https://sg.run/Bpj2                                                                        
                                                                                                              
           95┆ $lOutput = shell_exec($lCommand);
    
    
          Taint comes from:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
    
          Taint flows through these intermediate variables:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
           91┆ $lCommand = escapeshellcmd("echo " . escapeshellarg($lMessage));
    
    
                This is how taint reaches the sink:
    
           95┆ $lOutput = shell_exec($lCommand);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.tainted-exec.tainted-exec
          Executing non-constant commands. This can lead to command injection. You should use
          `escapeshellarg()` when using command.                                             
          Details: https://sg.run/JAkP                                                       
                                                                                             
           95┆ $lOutput = shell_exec($lCommand);
    
    
          Taint comes from:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
    
          Taint flows through these intermediate variables:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
           88┆ $lCommand = "echo " . $lMessage; // Vulnerable: Direct input usage
    
    
                This is how taint reaches the sink:
    
           95┆ $lOutput = shell_exec($lCommand);
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.laravel.security.laravel-command-injection.laravel-command-injection
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the user input, and use safe methods for       
          executing the commands. In PHP, it is possible to use `escapeshellcmd(...)` and                     
          `escapeshellarg(...)` to correctly sanitize input when used respectively as system commands or      
          command arguments.                                                                                  
          Details: https://sg.run/JPYR                                                                        
                                                                                                              
           95┆ $lOutput = shell_exec($lCommand);
    
    
          Taint comes from:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
    
          Taint flows through these intermediate variables:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
           88┆ $lCommand = "echo " . $lMessage; // Vulnerable: Direct input usage
    
    
                This is how taint reaches the sink:
    
           95┆ $lOutput = shell_exec($lCommand);
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          105┆ echo json_encode(['message' => $lMessage, 'command' => $lCommand, 'security-level' =>
               $lSecurityLevel, 'timestamp' => date(DATE_TIME_FORMAT), 'result' => $lOutput],       
               JSON_PRETTY_PRINT);                                                                  
    
    
          Taint comes from:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
    
          Taint flows through these intermediate variables:
    
           78┆ $lMessage = isset($_POST['message']) ? trim($_POST['message']) : '';
    
    
                This is how taint reaches the sink:
    
          105┆ echo json_encode(['message' => $lMessage, 'command' => $lCommand, 'security-level' =>
               $lSecurityLevel, 'timestamp' => date(DATE_TIME_FORMAT), 'result' => $lOutput],       
               JSON_PRETTY_PRINT);                                                                  
    
                                            
    src/webservices/rest/ws-user-account.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          124┆ echo json_encode($lArrayResponse, JSON_PRETTY_PRINT);
    
    
          Taint comes from:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
          Taint flows through these intermediate variables:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
          117┆ $lArrayResponse['Result'] = "User '$lUsername' does not exist";
    
          117┆ $lArrayResponse['Result'] = "User '$lUsername' does not exist";
    
    
                This is how taint reaches the sink:
    
          124┆ echo json_encode($lArrayResponse, JSON_PRETTY_PRINT);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.injection.tainted-sql-string.tainted-sql-string
          User data flows into this manually-constructed SQL string. User data can be safely inserted into SQL
          strings using prepared statements or an object-relational mapper (ORM). Manually-constructed SQL    
          strings is a possible indicator of SQL injection, which could let an attacker steal or manipulate   
          data from the database. Instead, use prepared statements (`$mysqli->prepare("INSERT INTO test(id,   
          label) VALUES (?, ?)");`) or a safe library.                                                        
          Details: https://sg.run/lZYG                                                                        
                                                                                                              
          158┆ $lArrayResponse['Result'] = "Failed to insert account '$lUsername'";
    
    
          Taint comes from:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
          Taint flows through these intermediate variables:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
                This is how taint reaches the sink:
    
          158┆ $lArrayResponse['Result'] = "Failed to insert account '$lUsername'";
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          167┆ echo json_encode($lArrayResponse, JSON_PRETTY_PRINT);
    
    
          Taint comes from:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
          Taint flows through these intermediate variables:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
          158┆ $lArrayResponse['Result'] = "Failed to insert account '$lUsername'";
    
          158┆ $lArrayResponse['Result'] = "Failed to insert account '$lUsername'";
    
    
                This is how taint reaches the sink:
    
          167┆ echo json_encode($lArrayResponse, JSON_PRETTY_PRINT);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.injection.tainted-sql-string.tainted-sql-string
          User data flows into this manually-constructed SQL string. User data can be safely inserted into SQL
          strings using prepared statements or an object-relational mapper (ORM). Manually-constructed SQL    
          strings is a possible indicator of SQL injection, which could let an attacker steal or manipulate   
          data from the database. Instead, use prepared statements (`$mysqli->prepare("INSERT INTO test(id,   
          label) VALUES (?, ?)");`) or a safe library.                                                        
          Details: https://sg.run/lZYG                                                                        
                                                                                                              
          225┆ $lArrayResponse['Result'] = "Failed to insert account '$lUsername'.";
    
    
          Taint comes from:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
          Taint flows through these intermediate variables:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
                This is how taint reaches the sink:
    
          225┆ $lArrayResponse['Result'] = "Failed to insert account '$lUsername'.";
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          235┆ echo json_encode($lArrayResponse, JSON_PRETTY_PRINT);
    
    
          Taint comes from:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
          Taint flows through these intermediate variables:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
          225┆ $lArrayResponse['Result'] = "Failed to insert account '$lUsername'.";
    
          225┆ $lArrayResponse['Result'] = "Failed to insert account '$lUsername'.";
    
    
                This is how taint reaches the sink:
    
          235┆ echo json_encode($lArrayResponse, JSON_PRETTY_PRINT);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ php.lang.security.injection.tainted-sql-string.tainted-sql-string
          User data flows into this manually-constructed SQL string. User data can be safely inserted into SQL
          strings using prepared statements or an object-relational mapper (ORM). Manually-constructed SQL    
          strings is a possible indicator of SQL injection, which could let an attacker steal or manipulate   
          data from the database. Instead, use prepared statements (`$mysqli->prepare("INSERT INTO test(id,   
          label) VALUES (?, ?)");`) or a safe library.                                                        
          Details: https://sg.run/lZYG                                                                        
                                                                                                              
          256┆ $lArrayResponse['Result'] = "Attempted to delete account '$lUsername', but the result
               returned was '$lQueryResult'.";                                                      
    
    
          Taint comes from:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
          Taint flows through these intermediate variables:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
                This is how taint reaches the sink:
    
          256┆ $lArrayResponse['Result'] = "Attempted to delete account '$lUsername', but the result
               returned was '$lQueryResult'.";                                                      
    
    
            ⋮┆----------------------------------------
   
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          274┆ echo json_encode($lArrayResponse, JSON_PRETTY_PRINT);
    
    
          Taint comes from:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
    
          Taint flows through these intermediate variables:
    
          101┆ $lUsername = $_GET['username'] ?? '';
    
          266┆ $lArrayResponse['Result'] = "User '$lUsername' does not exist.";
    
          266┆ $lArrayResponse['Result'] = "User '$lUsername' does not exist.";
    
    
                This is how taint reaches the sink:
    
          274┆ echo json_encode($lArrayResponse, JSON_PRETTY_PRINT);
    
                                       
    src/webservices/soap/lib/nusoap.php
   ❯❯❱ php.lang.security.eval-use.eval-use
          Evaluating non-constant commands. This can lead to command injection.
          Details: https://sg.run/J9AP                                         
                                                                               
          4188┆ @eval($funcCall);
            ⋮┆----------------------------------------
          8186┆ eval($evalStr);
            ⋮┆----------------------------------------
          8189┆ eval("\$proxy = new nusoap_proxy_$r('');");
   
    ❯❱ php.lang.security.unlink-use.unlink-use
          Using user input when deleting files with `unlink()` is potentially dangerous. A malicious actor
          could use this to modify or access files they have no right to.                                 
          Details: https://sg.run/rYeR                                                                    
                                                                                                          
          8566┆ unlink($filename);
   
    ❯❱ php.lang.security.unserialize-use.unserialize-use
          Calling `unserialize()` with user input in the pattern can lead to arbitrary code execution.
          Consider using JSON or structured data approaches (e.g. Google Protocol Buffers).           
          Details: https://sg.run/b24E                                                                
                                                                                                      
          8588┆ return (!is_null($s)) ? unserialize($s) : null;
   
    ❯❱ php.lang.security.unlink-use.unlink-use
          Using user input when deleting files with `unlink()` is potentially dangerous. A malicious actor
          could use this to modify or access files they have no right to.                                 
          Details: https://sg.run/rYeR                                                                    
                                                                                                          
          8676┆ $ret = unlink($filename);
                                          
    src/webservices/soap/ws-dns-lookup.php
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
          147┆ $lOutput = shell_exec($lCommand);
                                    
    src/webservices/soap/ws-echo.php
   ❯❯❱ php.lang.security.exec-use.exec-use
          Executing non-constant commands. This can lead to command injection.
          Details: https://sg.run/5Q1j                                        
                                                                              
          131┆ $lOutput = shell_exec($lCommand);
                         
    src/xml-validator.php
    ❯❱ php.lang.security.taint-unsafe-echo-tag.taint-unsafe-echo-tag
          Found direct access to a PHP variable wihout HTML escaping inside an inline PHP statement setting   
          data from `$_REQUEST[...]`. When untrusted input can be used to tamper with a web page rendering, it
          can lead to a Cross-site scripting (XSS) vulnerability. XSS vulnerabilities occur when untrusted    
          input executes malicious JavaScript code, leading to issues such as account compromise and sensitive
          information leakage. To prevent this vulnerability, validate the user input, perform contextual     
          output encoding or sanitize the input. In PHP you can encode or sanitize user input with            
          `htmlspecialchars` or use automatic context-aware escaping with a template engine such as Latte.    
          Details: https://sg.run/RlGe                                                                        
                                                                                                              
          179┆ echo "<div width='600px' class=\"important-code\">" . $Encoder->encodeForXML($lXML) .
               "</div>";                                                                            
    
    
          Taint comes from:
    
           73┆ $lXML = $_POST["xml"];
    
    
          Taint flows through these intermediate variables:
    
           73┆ $lXML = $_POST["xml"];
    
    
                This is how taint reaches the sink:
    
          179┆ echo "<div width='600px' class=\"important-code\">" . $Encoder->encodeForXML($lXML) .
               "</div>";                                                                            
    
